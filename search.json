[{"title":"弱者道之用","url":"/2025/06/11/20250611/","content":"\n## 弱者道之用\n“反者道之动，弱者道之用～”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"定义","url":"/2025/03/15/20250315/","content":"\n## 定义和被定义\n不要被定义是一件比较难的事情～\n","tags":["心情","日记"],"categories":["其他"]},{"title":"2025","url":"/2025/02/09/20250209/","content":"\n## 2025\n\n2025农历乙巳蛇年\n","tags":["心情","日记"],"categories":["其他"]},{"title":"黑神话-黑风大王","url":"/2024/12/15/20241215/","content":"\n## 人心烧没了，修好一座破庙，又有何用？\nRT\n","tags":["心情","日记"],"categories":["其他"]},{"title":"《病隙碎笔》- 命运","url":"/2024/10/21/20241021/","content":"\n## 命运\n---所谓命运，就是说，这一出“人间戏剧”需要各种各样的角色，你只能是其中一只，不可以随意调换。\n\n","tags":["心情","书摘"],"categories":["其他"]},{"title":"慈眉、善目","url":"/2024/09/16/20240915/","content":"\n## 黑猴子\n“慈眉掩善光，善目遮锋芒”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"小孩教育","url":"/2024/07/07/20240707/","content":"\n## 从小就得开始的三类别\n- 心理学  \n- 经济学  \n- 体育&历史&地理  \n前两者，在中国长期的教育体系里面很欠缺。近期的新闻有一些让人哀叹的事件。 \n","tags":["心情","日记"],"categories":["其他"]},{"title":"看破","url":"/2024/04/10/20240410/","content":"\n## 欣然接受\n看破还能欣然接受才是高手～\n","tags":["心情","日记"],"categories":["其他"]},{"title":"江山","url":"/2024/02/24/20240224/","content":"\n##  江山\n打江山应该赌，以小博大； \n守江山就该对冲，讲究博弈。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"2024","url":"/2024/01/01/20240101/","content":"\n## 20240101\n“接受自己早已看透的世界，带着灵魂的真光抵达爱和谦卑的内心” - 何家英 \n“盘桓绸缪间感悟大道玄机” - 吴为山\n今天在美术馆看到的两句话。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"认知这个词","url":"/2023/10/31/20231031/","content":"\n## 认知水平 \n时间线上你的决策和判断带来的结果就是认知水平的体现。否则都是认知信息，东拼西凑别人的经验和知识。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"Earned,not given","url":"/2023/10/12/20231012/","content":"\n##  earned,not given\n包括安全、生存、尊重等。 20231012 记巴-以\n\n","tags":["心情","日记"],"categories":["其他"]},{"title":"多行不义必自毙","url":"/2023/08/28/20230828/","content":"\n## 日本福岛核废水排海\n其实也没啥，做到标准就行，就是带了个坏头。\n\n","tags":["心情","日记"],"categories":["其他"]},{"title":"父亲节","url":"/2023/07/21/20230721/","content":"\n## 父亲节\n其实父亲节过去了一个多月了。“最棒的爸爸”\n![dady](20230721/bb.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"同侪悖论","url":"/2023/07/05/20230705/","content":"\n## 同侪悖论\n同侪悖论讲的就是一个典型的人性弱点。得与失、攀和比的参照依赖会让人做出错误的决策。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"低调","url":"/2023/06/25/20230625/","content":"\n## 低调\n低调久了会被人看低？\n","tags":["心情","日记"],"categories":["其他"]},{"title":"AI革命","url":"/2023/06/21/20230621/","content":"\n## AI\n就像工业革命一样，现在的人们腻歪了塑料感、千篇一律、精致，喜欢古法、手工、匠心等，总有一天他们也会看腻AI的生成。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"富贵儿","url":"/2023/05/23/20230523/","content":"\n## 无题\n![fg](20230523/fugui.jpeg)\n\n","tags":["心情","日记"],"categories":["其他"]},{"title":"污点","url":"/2023/05/21/20230521/","content":"\n## 污点\n污点就留给时间慢慢漂白，但漂白的痕迹仍然会在\n","tags":["心情","日记"],"categories":["其他"]},{"title":"莫过于心贫","url":"/2023/05/21/20230519/","content":"\n## 心贫\n一个人心里贫瘠能到一个什么样的地步，有哪些言语、行为？\n","tags":["心情","日记"],"categories":["其他"]},{"title":"母亲节","url":"/2023/05/14/20230514/","content":"\n## 母亲节\n“临行密密缝，意恐迟迟归” 妈妈的心思就和这句一样，尽管我的嘴上几十个不愿意。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"又是一年清明","url":"/2023/04/08/20230408/","content":"\n## 34岁的清明节\n这个年龄段，应该是面对死亡告别逐渐变多的岁数了。我以为忘了想念\n","tags":["心情","日记"],"categories":["其他"]},{"title":"什么是对的事","url":"/2023/03/28/20230328/","content":"\n##  对的事\n“让你从心里感动的事，就一定不是坏事。”   \n在你被一套套完全相反的道理说得无法取舍的时候。你要想一个是让你真的会感动的，对你来说，那就是对的。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"知行合一","url":"/2023/03/18/20230318/","content":"\n## 知行合一\nwhat the fuck！\n","tags":["心情","日记"],"categories":["其他"]},{"title":"驱动力","url":"/2023/02/05/20230205/","content":"\n## 驱动力\n如果人生是一场无限的游戏，我把玩家分为两种，内在驱动的人和外在驱动的人。前者意志坚定知道每个阶段想要的是什么，后者易被形形色色的外物干扰。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"2023 新年","url":"/2023/01/07/20230107/","content":"\n## 2023新年\n社会在逐步放开，有些人也在经历苦难。逝者已逝，愿生者清醒。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"乌合之众","url":"/2022/10/29/20221029/","content":"\n## 乌合之众\n人民似乎热爱平等、自由，大部分只是痛恨主子罢了。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"不如读书","url":"/2022/10/16/20221016/","content":"\n## 读书\n“吹灭读书灯，一身都是月”  \n![书](20221016/dushu.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"纯粹","url":"/2022/10/12/20221012/","content":"\n## 纯粹\n专业和人品\n","tags":["心情","日记"],"categories":["其他"]},{"title":"多肉","url":"/2022/09/24/20220924/","content":"\n## 多肉0924\n❤️![肉](20220924/duorou0924.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"入学","url":"/2022/09/07/20220907/","content":"\n## 入学\nbubu仔入学了。就是会想到自己初中毕业时候一个老师的一句话“一屋不扫，何以扫天下”。这个老师是我的父亲，也是年级的主任，也是学校的校长。他给初三学子最后一年的寄语。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"娱乐至死","url":"/2022/07/17/20220717/","content":"\n## 稀缺\n今天在书店的角落读到了一本“娱乐至死”译本的序，提序的作者大致这么个意思：  \n在信息和行动比率严重失调的现在，行动都显得珍贵。 \n在电子信息如此便捷的时代，我们会陷入自以为是的聪明，显得轻飘。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"父亲节","url":"/2022/06/19/20220619/","content":"\n## 父亲节\n就是想到李健的那首“父亲的散文诗”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"不变","url":"/2022/06/16/20220616/","content":"\n## 不变\n初心不变，无惧山海\n","tags":["心情","日记"],"categories":["其他"]},{"title":"个人权威","url":"/2022/04/15/20220415/","content":"\n## 权威\n组织权威和个人权威。  \n发现好多Manager只有组织权威，没有个人权威，但一般也都这样。那么问题来了，个人权威来源于什么，始于专业，终于人品？\n","tags":["心情","日记"],"categories":["其他"]},{"title":"视八极","url":"/2022/04/08/20220408/","content":"\n## 饮酣视八极\n俗物皆茫茫。  杜甫\n","tags":["心情","日记"],"categories":["其他"]},{"title":"哗众取宠","url":"/2022/03/27/20220327/","content":"\n## 哗众取宠\n“惑者既失精微,而辟者又随时抑扬,违离道本,苟以哗众取宠.”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"贤贤易色","url":"/2022/01/28/20220119/","content":"\n## 贤贤易色\n子夏曰：“贤贤易色；事父母，能竭其力；事君，能致其身；与朋友交，言而有信。虽曰未学，吾必谓之学矣。”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"游戏","url":"/2022/01/06/20220106/","content":"\n## 游戏\n人们热衷于有限游戏里面的“头衔”，但人生是一场无限游戏，尽管里面夹杂着大大小小带着规则的游戏。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"羁绊","url":"/2021/11/18/20211118/","content":"\n## 羁绊\n斩断羁绊的不是那个地方太遥远，而是那片土地上的人们早已不存在了\n","tags":["心情","日记"],"categories":["其他"]},{"title":"逻辑","url":"/2021/10/27/20211027/","content":"\n## 逻辑\n>逻辑被使用在大部分的智能活动中，但主要在心理、学习、哲学、语义学、数学、推论统计学、脑科学、法律和计算机科学等领域内被视为一门学科。逻辑讨论逻辑论证一般会呈现的一般形式，哪种形式是有效的，以及其中的谬论。\n>  逻辑推理通常可分为三种：归纳推理、溯因推理和演绎推理。 科学方法都属于归纳推理, 没有必然性。 数学则属于演绎推理。\n>  在哲学里，逻辑被应用在大多数的主要领域之中：形而上学/宇宙论、本体论、知识论及伦理学。\n>  在数学里，逻辑是指形式逻辑和数理逻辑，形式逻辑是研究某个形式语言的有效推论。主要是归纳和演绎推理。 在辩证法中也涉及到逻辑。数理逻辑是研究抽象逻辑关系和数学基本的问题。\n\n  挺有意思的一个现象：很多时候人们为了说服你，会自己出一个逻辑规则出来，按照这个可能假性质的逻辑规则给你讲推出来的结论。实际上去掉这个假性逻辑规则，翻译一下就是“我觉得是这样”。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"知行合一","url":"/2021/10/18/20211018/","content":"\n## 知行合一\n人最大的痛苦就是无法跨越知道和做到的鸿沟\n","tags":["心情","日记"],"categories":["其他"]},{"title":"梦","url":"/2021/09/09/20210909/","content":"\n## 梦\nWhat Life Could Mean to You 这本书的一个独立章节和其他章节若干部分对\"梦\"有一个个体心理学派的讲述。梦境和现实并不对立，而是现实的变异，它提供了现实问题一种解决方法的潜伏思想。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"观","url":"/2021/08/19/20210819/","content":"\n## 观\n咬文嚼字，“观” 这个字解释为“又见”。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"功利","url":"/2021/07/08/20210708/","content":"\n## 功利\n功利是一个中性词，所以别那么不好意思和隐晦的表达自己的想法，比如我想赚钱，我想要名誉。 哲学里面功利主义是：提倡追求“最大幸福”（Maximum Happiness）。所以放开表现去追求功利吧，但不要急功近利。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"敬畏","url":"/2021/06/11/20210611/","content":"\n## 敬畏之心\n可以“逆流而上”而不“逆天改命”，所以一定要做一个抱有敬畏之心的人。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"信","url":"/2021/05/14/20210514/","content":"\n## 信\n“在那最深奥、最重要的事物上，我们是无名的孤单”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"不渡他人","url":"/2021/04/29/20210429/","content":"\n## 但行好事 不渡他人\n-\n","tags":["心情","日记"],"categories":["其他"]},{"title":"小王子","url":"/2021/03/19/20210319/","content":"\n## 小王子\n又翻到了小王子。“生命有时候不需要一个形式上的终点”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"双“超”","url":"/2021/03/18/20210318/","content":"\n## 双超\n双\"超\" 是小平同志提出来的。在军备竞赛中其实也有一个双超的概念，不过是“抄袭”和“超越”，从历史看这个策略对于快速发展来说非常有效。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"背影","url":"/2021/02/25/20210225/","content":"\n## 背影\n\n![f](20210225/beiying.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"无题","url":"/2021/01/15/20210115/","content":"\n## 无题\n十多年来，自己最大的变化就是谦逊、虔诚了不少。\n比如十多年前在东九楼的教室，鄙视着来宣讲的小龙做的这个是什么垃圾，不及QQ的十分之一。\n然而，这么多年来我吭哧吭哧搞的东西，可能万分之一都达不到。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"复利","url":"/2021/01/12/20210112/","content":"\n## 复利\n可能听到最多的就是“时间的复利”、“金钱的复利”等，却很少有人告诉你“知识的复利”。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"悟·空","url":"/2021/01/08/20210108/","content":"\n## 悟·空\n突然发现悟空这个名字非常不错，词穷到只能用好形容。  \n>>悟：悟性、开悟，详见百科，“悟者，吾之心也！一人一悟性，只可意会，难以言传之智慧也！”[悟性](https://baike.baidu.com/item/%E6%82%9F%E6%80%A7)  \n>>空：“万法皆空，因果不空”、“本来无一物，何处惹尘埃”  \n\n![wk](20210108/wk.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"正确","url":"/2020/11/26/20201126/","content":"\n## 正确\n一般的说法，做正确的事情，进一步的说法是把事情做正确。\n但它们的前提都是“什么是正确的，而不是谁是正确的”，你敢吗？\n","tags":["心情","日记"],"categories":["其他"]},{"title":"能战方能止战","url":"/2020/11/16/20201116/","content":"\n## 能战方能止战\n“能战方能止战”是一种军事辨证论，当然用在产品上也是非常不错的。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"读史","url":"/2020/11/09/20201109/","content":"\n## 无题\n读史是不会错的，特别是没有感情色彩的纪录片。所以推荐大家多读读“史记”，当然指的是广义的“史记”，比如纪实书籍、军事纪录片。虽然现在很多文章里面讲述的多是故事，并且很多受众也喜欢看。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"恭卑","url":"/2020/10/13/20201013/","content":"\n## 阅历越多的人越发恭卑\n--\n","tags":["心情","日记"],"categories":["其他"]},{"title":"事在人为","url":"/2020/09/23/20200923/","content":"\n## 事在人为\n事在人为，强调的是\"事\"还是\"人\"，或者是\"为\"。不是客观的事，而是主观的人，所以人很重要。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"2000~2020","url":"/2020/09/17/20200917/","content":"\n## 2000~2020\n不知怎么的，突然想到千禧之年的一些片段。时间过去了20年，世界变化很大。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"杀心观音","url":"/2020/08/18/20200818/","content":"\n## 杀心观音\n比较喜欢西游相关的衍生题材IP， 杀心观音 这个称呼比较喜欢，兼顾了善恶\n","tags":["心情","日记"],"categories":["其他"]},{"title":"关于做规划","url":"/2020/07/09/target/","content":"\n## 关于做规划\n\n在iPad上面画了下，各个阶段应该适用:  \n![guihua](target/targetroute.jpg)\n","tags":["服务"],"categories":["系统"]},{"title":"谈谈服务稳定性","url":"/2020/06/19/stability/","content":"\n## 关于服务稳定性的思考\n\n在iPad上面画了下，写了写:  \n![wendingxing](stability/stability.png)\n","tags":["服务"],"categories":["系统"]},{"title":"今夕何夕","url":"/2020/06/17/20200617/","content":"\n## 今夕何夕\n >>“文山写的词就像他自己说的一样像一个电影，而林夕写的词像一本故事”\n\n 买给么么的airpods 两天就不知道踪影了 ==！\n","tags":["心情","日记"],"categories":["其他"]},{"title":"忘却感性的烦恼","url":"/2020/05/19/20200519/","content":"\n## 忘却感性的烦恼\n >>“六项精进”\n\n 1、付出不亚于任何人的努力\n 2、要谦虚，不要骄傲\n 3、要每天反省\n 4、活着，就要感谢\n 5、积善行、思利他\n 6、忘却感性的烦恼\n\n 这六点稻盛和夫虽然是写给企业经营，对于人生来说也是适用的指导啊\n","tags":["心情","日记"],"categories":["其他"]},{"title":"人生第一次","url":"/2020/04/21/20200421/","content":"\n## 《人生第一次》\n >>《人生第一次》是一个纪录片，我和我爱人一起看完的。\n \n爷爷去世那年的春节，父亲低头答复友人的那几句: “睡觉中...”、“走的很安详”\n那是一个儿子对父亲的结语，印在我的脑海里。有时候会像闪念一样，被现在生活的某个片段勾起。\n无能为力莫过于注定需要失去，然而自然里面也赋予了新生。我们在面对。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"云养娃","url":"/2020/04/09/20200409/","content":"\n## 云养娃两个多月，还是感谢科技的进步\n写到养娃，突然想到几年前的一篇笔记，来自一门不错的公开课\n![==！](20200409/wa.png)\n所以看人，需要看TA的家庭、儿女，而不仅仅TA自己\n比起川普秀，更喜欢看到他女儿女婿以及夫人的资讯\n","tags":["心情","日记"],"categories":["其他"]},{"title":"疫情第一天上班记录","url":"/2020/03/02/20200302/","content":"\n## 2020 新冠状疫情\n早上看了下小㘵㘵， 然后和么么（老家这样叫她）一起上班去了\n","tags":["心情","日记"],"categories":["其他"]},{"title":"奋发有为","url":"/2020/01/19/20200119/","content":"\n## “奋发有为”\n中国现代史的外交策略变化, 从“韬光养晦”到“奋发有为”, 好精辟并且喜欢的两个词。  \n不同阶段的打法不一样吧。  \n","tags":["心情","日记"],"categories":["其他"]},{"title":"system","url":"/2020/01/10/20200110/","content":"\n## system\n系统还是体系，这两个词其实都一样是system  \n但在体系比系统层次高一些, 类似Pod相对于Container\n","tags":["心情","日记"],"categories":["其他"]},{"title":"“第一性原理”","url":"/2019/12/19/20191220/","content":"\n## 第一性原理\n最近马斯克的皮卡挺火的(当然这个词较早也是他带火起来) 为什么他的皮卡是这样？\n首先看看百科的解释“每个系统中存在一个最基本的命题，它不能被违背或删除。通过第一性原理，把事情升华到最根本的真理，然后从最核心处开始推理”  \n\n我的理解，反向去看看，没说要正面理解    \n- 是不是一种批判性思维和对比性思维流程的碰撞，先遏制下对比思维\n- 是逆向金字塔生成的思维方式\n\n为什么想说说这个词的缘由  \n- 绝大部分做的都不是最好的，所以一般大家去追赶、对齐就满足了\n- 往往处于领先或者需求突破的时候就陷入瓶颈，说白了你没有“抄”的\n","tags":["心情","日记"],"categories":["其他"]},{"title":"守正出奇","url":"/2019/12/17/20191217/","content":"\n## 2019\n\"守正出奇\" 2019 对这个词有自己的一点点理解，特别是某些场景下  \n我认为的背景\n- 不同阶段不一样，有时候需要破釜沉舟、孤注一掷的plan A\n- 不是单打独斗，大部分需要利益得到满足，多也好、少也罢  \n\n我认为的理解\n- 需要有符合预期的成绩和价值\n- 任何时候都需要额外准备你的B方案，确保大概率“制胜”\n\n会不会在表现上不那么aggressive。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"成长环- The Growth Rings","url":"/2019/11/26/20191126/","content":"\n## The Four Growth Rings\n> 稳定（停滞）（Stagnation）\n> 秩序（Order）\n> 复杂（Complexity）\n> 混乱（Chaos）\n> 仅仅只是四种环境状态，你可以是任何角色：学生、老师、管理者、组员、教练或者父母。现在的你处在哪一层？\n<!-- more -->\n### 分析\n\n- Stagnation: a low performing, or negative growth environment.\n- Order: a comfortable environment that leads to a predictable outcome.\n- Complexity: an unpredictable environment where the outcomes are unknown.\n- Chaos: an environment of little to no control where growth is halted by high turmoil.\n\n---\n\n- 稳定(停滞), 低效的成长环境\n- 秩序, 一个可控的状态\n- 复杂, 存在未知挑战的状态\n- 混乱, 失控往往会阻塞成长。如果能从“混乱”主导到“复杂”也是不错的成长\n\n## 总结\n- 成长发生在环境改变或者考验你的时候，不论哪一种\n- 理想上来看“秩序”是一种较完美的环境状态，但合适的导向到“复杂”状态环境能最大化潜能发掘和成长\n","tags":["心情","日记"],"categories":["其他"]},{"title":"大道理","url":"/2019/11/14/20191114/","content":"\n## 理\n> 大道理人人都懂，会遇到大部分人的反感，人们产生抵触甚至叛逆等，但往往只会有少数经历过这些道理的人才会刻骨铭心的懂\n","tags":["心情","日记"],"categories":["其他"]},{"title":"时间的复利","url":"/2019/11/12/20191112/","content":"\n## 时间复利\n> 复利往往比较可怕，时间的复利更可怕。比如1.01^365\n- 尽早的投资：投资自己\n- “每天前进30公里”\n- 高回报在复利曲线的后半段，通常是过了某个临界点\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-单向链表元素两两交换","url":"/2019/11/12/A_leecode_swappaires_/","content":"\n## 题目解析\n\n> Given a linked list, swap every two adjacent nodes and return its head.\n> Example:\n<!-- more -->\n> Given 1->2->3->4, you should return the list as 2->1->4->3.\n> Note:\n> Your algorithm should use only constant extra space.\n> You may not modify the values in the list's nodes, only nodes itself may be changed.\n> 分析单向链表 需要知道头结点才能做头结点后的节点数据交换（此case是两节点）。\n> 实际先交换节点1，2 变成2-1-3-4， 此时2节点为结果的头结点，但是后面的节点没处理\n> 然后按照知晓头结点1 处理1-3-4中的3，4 交换， 依次类推处理知道节点后面小于2个节点退出\n\n\n\n## 分析\n重要点知晓这几类就思路就明白了\n1、单向链表仅有一个头结点\n2、单向链表的某个节点操作需要知晓它的previous节点\n\n代码演示：\n```java\npackage com.dylan326.apus;\n\n/**\n * Given a linked list, swap every two adjacent nodes and return its head.\n *\n * Example:\n *\n * Given 1->2->3->4, you should return the list as 2->1->4->3.\n * Note:\n *\n * Your algorithm should use only constant extra space.\n * You may not modify the values in the list's nodes, only nodes itself may be changed.\n *\n * 分析单向链表 需要知道头结点才能做头结点后的节点数据交换（此case是两节点）。\n * 实际先交换节点1，2 变成2-1-3-4， 此时2节点为结果的头结点，但是后面的节点没处理\n * 然后按照知晓头结点1 处理1-3-4中的3，4 交换， 依次类推处理知道节点后面小于2个节点退出\n */\npublic class A24SwapPairs {\n\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) { // 初始条件判定\n            return head;\n        }\n        // 首节点交换逻辑 result为结果即头结点， 但是当前后面的数据还没处理\n        ListNode result = new ListNode(head.next.val);\n        head.next = head.next.next;\n        result.next = head;\n        ListNode node = head; // 此时2-1-3-4\n        while (node.next!=null && node.next.next !=null ){  // 循环退出即后面小于两个节点 不需要做交换\n            ListNode tmp1 = node.next; // 处理例子 1-3-4； 1节点后面的数据\n            ListNode tmp2 = node.next.next.next;\n            node.next = tmp1.next;\n            node.next.next = tmp1;\n            tmp1.next = tmp2; // 结束后1-4-3\n\n            node = tmp1; // 重置循环初始条件 此时例子应该为 3节点。 如果后面还有数据\n        }\n        return result;\n    }\n}\n\n```\n\n\n代码演示：\n\n代码文件：\n[A24SwapPairs.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A24SwapPairs.java)\n\n### 总结\n- 实际单向链表的某个节点操作需要什么条件\n- 演变问题1: 每三个交换如何处理\n- 演变问题2: 比较常见，原链表空间翻转单向链表\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"三个选择","url":"/2019/11/11/20191111/","content":"\n## 选择\n> 绝大多数场景下你只有如下三个选择：\n- 适应它\n- 改变它\n- 离开它\n","tags":["心情","日记"],"categories":["其他"]},{"title":"Think more","url":"/2019/11/05/20191105/","content":"\n## 今天你思考了吗\n> 大多数人喜欢用勤快的行动来掩盖思想上的懒惰 -Dylan\n> “多数人为了逃避真正的思考是愿意做任何事情的”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"人格自立","url":"/2019/10/15/20191015/","content":"\n## 明德\n> 明德、厚学。我劝天公重抖擞，不拘一格降人才。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"70周年国庆","url":"/2019/09/30/20190930/","content":"\n## 小区公园到处都是红灯笼和红旗\n> 明天国庆，70周年。 小bubu 126天；小妈妈节后要去上班了，不知道能否适应这种状态\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A07-字符串匹配-KMP","url":"/2019/09/18/A07_zifuchuanpipei/","content":"## 单模式串字符串匹配\n给定单个字符串S（长度m），查找目标模式串pattern（长度n）。 这个问题常见的会是采用朴素匹配，\n<!-- more -->\n朴素匹配实际为暴力匹配（BrueForce）本文讲述的是[KMP算法, 维基百科](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm) 维基百科里面讲述的较详细， 就如下几个重点本文讲述下。\n\n### KMP相对朴素匹配\n本质上是在朴素匹配上做了一个剪枝， 朴素匹配在S串上依次对pattern串进行比较,复杂度O(m*n), 而KMP逻辑会进行跳过，复杂度O(m+n)。\n\n### KMP关键点\n- 理解字符串的真前缀（proper preffix）、真后缀（proper suffix）。不包含本身的前缀或者后缀，如snake的真前缀s，sn，sna，snak。\n- 真前缀和真后缀的相同意味着什么，这个理解清楚了就是KMP对比跳过的剪枝逻辑。理解见代码\n- next()函数表及实现\n- 根据next()函数遍历目标串S\n\n代码演示：\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class C10StrPattern {\n\n    /**\n     * 生成模式串next函数，函数作用为主串对比忽略比较的位置记录\n     * 表示的含义当前位置，真前缀和真后缀相同的个数， 正因为相同，所以已经比较过的可以根据这个信息直接跳到比较位置\n     * @param pattern 匹配模式串\n     * @return\n     */\n    private static int[] genNextArray(String pattern) {\n\n        if (pattern == null || pattern.length() == 0) {\n            return new int[]{};\n        }\n        int[] result = new int[pattern.length()];\n        result[0] = 0;// 一个元素自己，真前、后缀相同个数为0\n        for (int i = 1; i < pattern.length(); i++) {\n            if (pattern.charAt(i) == pattern.charAt(result[i - 1])) { //当前元素和result记录值\n                result[i] = result[i - 1] + 1;\n            } else {\n                result[i] = 0;\n            }\n\n        }\n        return result;\n    }\n\n    /**\n     * @param str\n     * @param pattern\n     * @return [\"1-4\",\"6-9\"]\n     */\n    public static List<String> findPosition(String str, String pattern) {\n        List<String> result = new ArrayList<>();\n        if (str == null || pattern == null || str.length() == 0 || pattern.length() == 0) { // 不合理过滤\n            return result;\n        }\n        int[] next = genNextArray(pattern); // 生成next函数， 信息表\n        int i = 0, start = 0;\n        while (i < str.length()) {\n            for (int j = 0; j < pattern.length(); j++) {\n                if (i + j > str.length() - 1) { // 如果剩下的长度不符合直接退出后续查找\n                    return result;\n                }\n                if (str.charAt(i + j) == pattern.charAt(j)) {\n                    if (j == 0) { // j==0 并且i+j位置和 pattern串j位置相等，可能的起始位置记录\n                        start = i;\n                    }\n                    if (j == pattern.length() - 1) {// 找到并且结束\n                        result.add(String.format(\"%s-%s\", start, i + j));\n                        i++; // **  注意此处从i+1开始继续，而不是当前找到的模式串结束位置\n                        break;\n                    }\n                } else { // ** 不相等 源串遍历索引i 直接跳到next() 位置。 加不加1 取决于next记录值， 有些实现next值默认-1，所以此处不用加1\n                    i = i + next[j] + 1;\n                    break;\n                }\n            }\n\n        }\n\n        return result;\n    }\n\n\n    public static void main(String[] args) {\n        //示例\n        //abababca  原始串S   pattern串aba\n        //01234567  索引值\n        //00123401  next() 函数，剪枝跳跃的信息表\n        System.out.println(Arrays.toString(findPosition(\"abababca\", \"aba\").toArray()));\n    }\n}\n    \n\n```\n\n\n\n代码文件：[C10StrPattern.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C10StrPattern.java)\n\n## 总结\n- \"KMP关键点\" 前两点是理解关键，后两点是实现\n- AC自动状态机本质来说是KMP的一个多模式演变， 多模串仅一个分支的话就是KMP\n\n机器在于运动，大脑也需要不断思考运作才能避免秀逗\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","数据结构"],"categories":["算法"]},{"title":"每句话","url":"/2019/08/28/20190828/","content":"\n## 每一句话\n> 因为有爱，所以每句话要好好说\n","tags":["心情","日记"],"categories":["其他"]},{"title":"消息ID设计选型","url":"/2019/08/06/id_desgin/","content":"\n## 背景和目标\n需要一个唯一数据标示\nID类型可以使字符串或者整型。 这两类选择对方案影响较大\nID生产性能， 决定服务瓶颈\nID生产容灾解决， 如果ID是你的系统十分重要的数据，那么容灾较为重要\n<!-- more -->\n## 可行的解决方案\n- 大数， 参考一般电商系统订单ID\n- uniq字符串 ， 可参考UUID、MongoObjectID等\n- MySQL 主键\n- redis incr\n\n\n### 参考\nsnowflake\nhttps://developer.twitter.com/en/docs/basics/twitter-ids.html\nhttps://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html\n\n#### 优点\n- 长整型处理性能相对较高\n- 生产性能高\n- 生成分布式容错\n\n#### 弊端\n- 时间有限，取决于设计的其实时间戳， 目前可使用年限有限， 取决于分配的位数和起始时间戳\n- 机器时间回拨，会导致循环hang一段时间，直到比上次生产ID值大\n- 每一毫秒2^12次， 单节点QPS过大，也会导致hang住一段时间\n- workID，个数有限，可以做成rpc， 产生了rpc调用时耗\n\n## 可参考其他实现\n侧重不一样，导致实现有难易\n- MQ messageid  例如kafka\n- RPC requestID。 例如dubbo 只需要保证某次连接上唯一\n- TCP/IP 序列id\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["IM","DX","微信"],"categories":["THINK"]},{"title":"鲸","url":"/2019/07/10/20190710/","content":"\n## 化身孤岛的鲸\n>最近听到了一首填词的歌《化身孤岛的鲸》，让我想起“大鱼海棠”里面的鲲\n>贴下填的词\n\"我想给你能奔跑的岸头\n让你如同王后\"\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-和为目标值问题","url":"/2019/06/26/A_leecode_combination_sum/","content":"\n## 题目解析\n>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n>The same repeated number may be chosen from candidates unlimited number of times.\n<!-- more -->\n\n\n\n## 分析\n1、这类问题其实条件较重要，候选数字无重复、目标结果唯一\n\n思路方法\n### 方法一\n这类问题递归（回溯）去处理只需要明确递归函数参数定义和含义，其实问题就解决了一大半了\n- 详见代码参数注释\n\n代码演示：\n```java\npackage com.dylan326.apus;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 条件都是正数，backtracking 模式， 之前的三数和或者三数靠近和， 回溯模式也能解决\n * 回溯解决的一类问题\n */\npublic class A39combinationSum {\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\n        return list;\n    }\n\n    /**\n     *\n     * @param list 结果集合\n     * @param tempList 结果\n     * @param nums 候选数组\n     * @param remain 目标值在当前循环或者递归剩下值，当前题目及target（上次的remain-nums[i]）\n     * @param start 回溯开始的起始位置\n     */\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {\n        if (remain < 0) {\n            System.out.println(\"-----illegal=\"+Arrays.toString(tempList.toArray()));\n            return;\n        }\n        else if (remain == 0) { // 结果条件\n            System.out.println(\"found=\"+Arrays.toString(tempList.toArray()));\n            list.add(new ArrayList<>(tempList)); //  新数组对象保留结果\n        } else {\n            for (int i = start; i < nums.length; i++) {\n                tempList.add(nums[i]);\n                System.out.println(\"=add=\"+nums[i]+\",array=\"+Arrays.toString(tempList.toArray()));\n//                backtrack(list, tempList, nums, remain - nums[i], i + 1);// start 参数取决于包不包含自己\n                backtrack(list, tempList, nums, remain - nums[i], i);// 回溯开始位置从当前元素开始\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        A39combinationSum a39combinationSum = new A39combinationSum();\n        System.out.println(Arrays.toString(a39combinationSum.combinationSum(new int[]{7, 2, 3, 4}, 7).toArray()));\n    }\n}\n\n```\n\n\n代码演示：见 A39combinationSum.java\n\n代码文件：\n[A39combinationSum.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A39combinationSum.java)\n\n### 总结\n\n- 退出递归条件、或者找到结果条件\n- 实际为递归全组合的一种剪枝方式\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"买了一本书作为礼物","url":"/2019/06/18/20190618/","content":"\n## 世事如书\n<!-- more -->\n>  我只爱你这一句， 从前车马很慢... @Echo\n>\n","tags":["心情","日记"],"categories":["其他"]},{"title":"五月","url":"/2019/05/07/20190507/","content":"\n## 期许\n<!-- more -->\n> 今年的五月，让人期待的一个月份 @Dylan @Echo\n>\n","tags":["心情","日记"],"categories":["其他"]},{"title":"2019-春雪","url":"/2019/02/13/20190213/","content":"\n## 2019\n<!-- more -->\n> 2019 注定不平凡的一年 @Dylan @Echo\n> 故宫下雪了，如何才能拍出一个人的紫禁城\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-三数和[Three Sum] or N数和或者相近","url":"/2019/01/28/A_leecode_sum3orN/","content":"\n## 题目解析\n>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n>Note:\n> The solution set must not contain duplicate triplets.\n<!-- more -->\n\n\n\n## 分析步骤\n1、条件给出子元素三个和为0\n2、限制和前置条件， 非重复数组\n3、思路：最直接的思路未尝不好， 限制仅为3数\n\n代码演示：\n```java\npublic class A15Sum3 {\n\n    /**\n     * 直接处理方式\n     *\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static List<List<Integer>> sum3(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        if (nums.length < 3) { // 初始条件检查\n            return result;\n        }\n        Arrays.sort(nums); // 排好序\n        for (int i = 0; i < nums.length; i++) {\n            int start = i + 1, end = nums.length - 1;\n            int tmp = target - nums[i];\n            if (i > 0 && nums[i] == nums[i - 1]) { // 相等元素 继续下一个\n                continue;\n            }\n            while (start < end) {\n                if (tmp < nums[start] + nums[end]) {\n                    end--;\n                } else if (tmp > nums[start] + nums[end]) {\n                    start++;\n                } else {\n                    List<Integer> tmp2 = new ArrayList<Integer>();\n                    tmp2.add(nums[i]);\n                    tmp2.add(nums[start]);\n                    tmp2.add(nums[end]);\n                    start++;\n                    end--;\n                    while (start < end && nums[start] == nums[start - 1]) {\n                        start++;\n                    }\n                    while (end > start && nums[end] == nums[end + 1]) {\n                        end--;\n                    }\n                    result.add(tmp2);\n                }\n            }\n\n\n        }\n        return result;\n    }\n\n    /**\n     * N数和或者和靠近处理模式\n     *\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static List<List<Integer>> sum3New(int[] nums, int target) {\n        Map<List<Integer>, List<Integer>> result = new HashMap<>();\n        Arrays.sort(nums);\n        sum3Backtracking(result, new ArrayList<Integer>(), nums, target, 0);\n        return new ArrayList<>(result.values());\n    }\n\n    /**\n     * backtracking 来处理\n     *\n     * @param result\n     * @param item\n     * @param nums\n     * @param remain\n     * @param start\n     */\n    public static void sum3Backtracking(Map<List<Integer>, List<Integer>> result, List<Integer> item, int[] nums, int remain, int start) {\n        if (nums.length> 0 && remain < minArraySum(nums)) {\n            return;\n        } else if (remain == 0 && item.size() == 3) { // 符合结果值\n            result.put(new ArrayList<>(item), new ArrayList<>(item)); // 按照题目要求，简单用hashmap去重复数组\n        } else {\n            for (int i = start; i < nums.length; i++) {\n                item.add(nums[i]);//* ① 添加当前元素\n                sum3Backtracking(result, item, nums, remain - nums[i], i + 1); //* ② 之前的目标值为remain-nums[i]\n                item.remove(item.size() - 1); // * ③ 回退元素\n            }\n        }\n    }\n\n    /**\n     * 计算出当前最小值， 退出递归的条件，减少递归次数\n     * @param nums\n     * @return\n     */\n    private static int minArraySum(int[] nums) {\n        int start = 0;\n        if (start >= nums.length) {\n            return Integer.MAX_VALUE;\n        }\n        if (nums[start] >= 0) {\n            return nums[start];\n        } else {\n            int min = 0;\n            for (int i = start; i < nums.length; i++) {\n                if (nums[i] < 0 && i < 4) {\n                    min += nums[i];\n                }\n            }\n            return min;\n        }\n    }\n\n\n    public static void main(String[] args) {\n        System.out.println(sum3(new int[]{0, 0, 0, 0, 0, 0}, 0));\n        System.out.println(sum3New(new int[]{0, 0, 0, 0, 0, 0}, 0));\n        //\n        System.out.println(sum3(new int[]{-2, -1, 0, 1, 2, 3}, 0));\n        System.out.println(sum3New(new int[]{-2, -1, 0, 1, 2, 3}, 0));\n    }\n}\n```\n\n\n代码文件：\n[A15Sum3.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A15Sum3.java)\n\n### 总结\n\n- 首先相当的类似回溯处理， 需要解决的是重复数组结果问题\n- 直接处理方式， 避免了重复检查， 当限制进位3数和，可以直接考虑\n- 延伸问题： N数和 或者 N数和接近，这类仅是结束条件变更的扩展\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"A-leecode-合并k个排序数组或链表[Merge k sorted array]","url":"/2019/01/09/A_leecode_merge_k_sorted_array/","content":"\n## 题目解析\n>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n>合并两数组，归并排序中的一个小步骤。 把这个小步骤演化为合并k个排好序的数组\n<!-- more -->\n\n\n## 分析步骤\n1、我们先实现两排序数组或者链表合并， 此为基本编码思路\n2、k个参数， 类比归并排序思想，两两合并\n3、考察2中的递归逻辑以及递归退出条件\n\n代码演示：\n```java\npublic class A23MergeKSortedList {\n\n\n    /**\n     * 分治+递归\n     * @param lists\n     * @return\n     */\n    public ListNode mergeKLists(ListNode[] lists) {\n\n        if (lists.length == 0) {// 边界值， 递归退出条件\n            return null;\n        } else if (lists.length == 1) {// 边界值， 递归退出条件\n            return lists[0];\n        } else if (lists.length == 2) {// 边界值， 递归退出条件\n            return merge2Lists(lists[0], lists[1]);\n        } else {\n            ListNode[] params;\n            if (lists.length % 2 == 0) { // 偶数个情况\n                params = new ListNode[lists.length / 2];\n                for (int k = 0; k < params.length; k++) {\n                    params[k] = merge2Lists(lists[k], lists[lists.length - k - 1]);\n                }\n            } else { // 偶数个情况\n                params = new ListNode[lists.length / 2 + 1];\n                for (int k = 0; k < params.length - 1; k++) {\n                    params[k] = merge2Lists(lists[k], lists[lists.length - k - 1]);\n                }\n                params[params.length - 1] = lists[lists.length / 2];\n            }\n            return mergeKLists(params); // 递归处理合并\n        }\n\n    }\n\n    /**\n     * merge2 合并两链表\n     * @param list1\n     * @param list2\n     * @return\n     */\n    public ListNode merge2Lists(ListNode list1, ListNode list2) {\n        ListNode node = new ListNode(0);\n        ListNode head = node;\n        while (true) {\n            if (list1 == null) {\n                node.next = list2;\n                break;\n            }\n            if (list2 == null) {\n                node.next = list1;\n                break;\n            }\n            if (list1.val == list2.val) {\n                node.next = new ListNode(list1.val);\n                node.next.next = new ListNode(list1.val);\n                node = node.next.next;\n                list1 = list1.next;\n                list2 = list2.next;\n            } else if (list1.val < list2.val) {\n                node.next = new ListNode(list1.val);\n                list1 = list1.next;\n                node = node.next;\n            } else {\n                node.next = new ListNode(list2.val);\n                node = node.next;\n                list2 = list2.next;\n            }\n        }\n        return head.next;\n    }\n\n    public static void main(String[] args) {\n        A23MergeKSortedList tmp = new A23MergeKSortedList();\n        ListNode a = new ListNode(1);\n        a.next = new ListNode(4);\n        a.next.next = new ListNode(5);\n\n        ListNode b = new ListNode(1);\n        b.next = new ListNode(3);\n        b.next.next = new ListNode(4);\n\n        ListNode c = new ListNode(2);\n        c.next = new ListNode(6);\n\n        tmp.mergeKLists(new ListNode[]{a, b, c});\n    }\n}\n```\n\n\n代码文件：\n[A23MergeKSortedList.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A23MergeKSortedList.java)\nTODO： 实际解决方案，k个有序联表\n\n### 总结\n\n- 就是和归并排序思想类似\n- 方案二，采用K大小的堆去维持合并的数据排序。待续\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"步入而立之年","url":"/2019/01/03/20190103/","content":"\n## 而立之年-2019\n<!-- more -->\n> 人格自立- 有着自己独特的人格魅力，支撑着家庭，影响着周围的人和事\n> 学识自立- 有着独立的知识自我学习体系，学习->思考->总结->传播\n> 事业自立- 事业成长体系，核心竞争力\n","tags":["心情","日记"],"categories":["其他"]},{"title":"兼听则明","url":"/2018/12/29/20181229/","content":"\n## 年末\n> 偏听偏言，兼听则明。2018总结词\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-轮转的排序数组查找元素[RotatedSortedArray]","url":"/2018/12/24/A_leecode_rotaed_sorted_array/","content":"\n## 题目解析\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n> (i.e., [0,1,2,3,4,5,6] might become [5,6,0,1,2,3,4]).\n> You are given a target value to search. If found in the array return its index, otherwise return -1.\n> You may assume no duplicate exists in the array.\n> Your algorithm's runtime complexity must be in the order of O(log n).\n<!-- more -->\n> 思路类比二分， 变种，比较中位数和左右两个边界大小， 能确定哪半边是有序，哪半边是转置。再比较大小确target再哪半边，有序的采用二分查找，转置的回到了初始问题\n\n\n排序数组中超找某个元素，二分查找较快速。 题目有点改动是此排序数组经过轮转， 其实本质还是按照二分查找的思路来\n\n## 分析步骤\n1、轮转的递增排序数组，有个特点， 我们取中位数后，必定有一段是单调增，另一段是轮转有序\n2、那么就是一个初始条件缩减问题， 如果目标数在单调增里面，那么二分查找，如果不在，回到了1流程初始问题\n3、考虑边界条件和循环退出条件\n\n代码演示：\n```java\npublic class A33RotatedSortedArray {\n\n    public int search(int[] nums, int target) {\n        int start = 0, end = nums.length - 1;\n        if (nums.length == 0) {\n            return -1;\n        }\n        if (target < nums[start] && target > nums[end]) {\n            return -1;\n        }\n        if (target == nums[start] && start == end) {\n            return start;\n        }\n        while (start <= end) {\n            int index = (start + end) / 2;\n            int tmp = nums[index];\n            if (tmp == target) { // 找到目标\n                return index;\n            }\n            if (tmp <= nums[end]) {\n                if (target >= tmp && target <= nums[end]) { // target 在有序右侧\n                    return searchSecond(nums, target, index, end);\n                } else { // target在转置左侧，重新调整右边界\n                    end = index - 1;\n                }\n            } else {\n                if (target >= nums[start] && target <= tmp) { // target 在有序左侧\n                    return searchSecond(nums, target, start, index);\n                } else { //// target在转置左侧，重新调整左边界\n                    start = index + 1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 二分查找\n     * @param nums\n     * @param target\n     * @param start\n     * @param end\n     * @return\n     */\n    private static int searchSecond(int[] nums, int target, int start, int end) {\n        while (start <= end) {\n            if (target < nums[start] || target > nums[end]) {\n                return -1;\n            }\n            int index = (start + end) / 2;\n            int tmp = nums[index];\n            if (tmp == target) {\n                return index;\n            }\n            if (target < tmp) {\n                end = index - 1;\n            } else {\n                start = index + 1;\n            }\n        }\n        return -1;\n    }\n```\n\n\n代码文件：\n[A33RotatedSortedArray.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A33RotatedSortedArray.java)\n\n### 总结\n\n- 如果前置条件变化，可能的一种是某些思路的理解演进或者举一反三。 还有一类是思考逻辑递进式\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"七个习惯摘要","url":"/2018/11/28/20181128/","content":"\n## 七个习惯\n>习惯一：积极主动 （BE  PROACTIVE）：采取主动，为自己过去、现在以及未来的行为负责 ，并依据原则及价值观，而非情绪或外在环境来下决定。\n>习惯二：以终为始（BEGIN WITH THE END IN MIND）： 所有事物都经过两次的创造——先是在脑海里酝酿，其次才是实质的创造。领导工作的核心，就是在共有的使命、愿景和价值观之后，创造出一个文化。\n>习惯三：要事第一（PUT FIRST THINGS FIRST）：实质的创造，是梦想的组织与实践。\n>习惯四：双赢思维（THINK WIN/WIN ): 是一种基于互敬，寻求互惠的思考框架与心意，目的是更丰富的机会、财富及资源，而非敌对式竞争。\n>习惯五：知彼解己（SEEK FIRST TOUNDERSTAND ，THEN  TORE  UNDERSTOOD）：当我们舍弃回答心，改以了解心去聆听别人，便能开启真正的沟通，增进彼此的关系。\n>习惯六：统合综效（SYNERGIZE）：非按照我的方式，亦非遵循你的方式，而是第三种远胜过于个人之见的办法。1+1大于2。\n>习惯七：不断更新（SHARPEN  THE SAW ） ：如何在身体、精神、智力，社会或情感四个基本生活层面不断更新自己。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-字典序下一个[NextPermutation]","url":"/2018/11/26/A_leecode_nest_permutation/","content":"\n## 题目解析\n>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n>The replacement must be in-place and use only constant extra memory.\n>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n<!-- more -->\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\n\n## 分析步骤\n关键要点\n1、左领位小的第一的数n，例子（4、5、3、2）依次是2，3，5，4 那么n=4\n2、找到4的右边比n=4大的最小的一个数，例子是5。 交换这两个数字\n3、n=4右边的数据排序为递增序列， 即从小到大排序 5、2、3、4\n\n代码演示：\n```java\n/**\n * Created by dylan on 2017/5/22.\n * 字典序的下一个数字, 如果没有则为原数组\n * 1,4,3,2 -> 2,1,3,4\n * 1,3,4,2 -> 1,4,2,3\n */\npublic class A31NextPermutation {\n\n    public static int[] next(int[] nums) {\n        int tmp1 = -1;\n        int index1 = 0;\n        for (int i = nums.length - 1; i > 0; i--) {//记录从右边开始查找，找到的第一个左邻位小的数\n            if (nums[i - 1] < nums[i]) {\n                tmp1 = nums[i - 1];\n                index1 = i - 1;\n                break;\n            }\n        }\n        if (tmp1 == -1) { // 找不到则为字典序的最大值， 下一个按照题要求为回到最小值\n//            return num;\n            int m = 0, n = nums.length - 1;\n            while (m < n) {\n                int tmp = nums[m];\n                nums[m++] = nums[n];\n                nums[n--] = tmp;\n            }\n            return nums;\n        }\n        int delta = Integer.MAX_VALUE;\n        int index2 = 0;\n        for (int i = index1 + 1; i < nums.length; i++) {//找到比tmp1大的最小数\n            if (nums[i] > tmp1 && nums[i] - tmp1 < delta) {\n                delta = nums[i] - tmp1;\n                index2 = i;\n\n            }\n        }\n        //swap\n        nums[index1] = nums[index2];\n        nums[index2] = tmp1;\n\n        //sort index1+1~ num.lengh\n        for (int i = index1 + 1; i < nums.length; i++) {// 对index1后面的数据按小到大排序\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] > nums[j]) {\n                    int tmp = nums[i];\n                    nums[i] = nums[j];\n                    nums[j] = tmp;\n                }\n            }\n        }\n        return nums;\n    }\n}\n```\n\n\n代码文件：\n[A31NextPermutation.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A31NextPermutation.java)\n\n### 总结\n\n- 定义的实现过程，如何把理解的定义程序化编写出来\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"小记一日","url":"/2018/11/13/20181026/","content":"\n## 哈哈\n拿着一张B超图，蹦蹦跳跳的给我说，快看快看，你的宝宝\nRT\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-移除元素[remove element]","url":"/2018/10/30/A_leecode_remove_element/","content":"\n## 题目解析\n>Given an array nums and a value val, remove all instances of that value in-place and return the new length.\n>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n>The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n>Example 1:\n>Given nums = [3,2,2,3], val = 3,\n>Your function should return length = 2, with the first two elements of nums being 2.\n>It doesn't matter what you leave beyond the returned length.\n<!-- more -->\n\n整型数组中移除和目标val相同的元素，返回剩下数据的长度n，数组前n元素是结果元素\n\n## 分析步骤\n1、返回非val元素个数n，并且数组前n是非val 元素， 注意顺序无要求\n2、除去n个元素外剩余的元素内容也没要求\n3、不开辟额外的数组空间\n\n代码演示：\n```java\n/**\n * Given an array nums and a value val, remove all instances of that value in-place and return the new length.\n *\n * Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n *\n * The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n * 分析 ：直接方案是遍历数组 遇到和val相同的元素 与后面不和val相同的元素交换\n * 此处小技巧， 后面不同于val的元素可以按照倒序来交换\n * 实现相对较OK  优于99.85%的提交\n */\npublic class A27RemoveElement {\n\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int end = nums.length - 1; // end标记需要交换的元素\n        for (int i = 0; i < nums.length; i++) {\n            if(i > end) break;\n            if(nums[i] == val){\n                while (nums[end]==val){// 从尾部向前找 第一个不等于val的元素\n                    end--;\n                    if(end <i){ // 全部是val的情况会导致end < 此时i的值， 返回统计计数\n                        return counter;\n                    }\n                }\n                int tmp = nums[i]; // 交换i和end元素位置\n                nums[i] = nums[end];\n                nums[end] = tmp;\n                end--;\n                counter++; // 和不同于val的元素交换后需要计数++\n            } else {\n                counter++; // 不同于val的元素 计数++\n            }\n        }\n        return counter;\n    }\n\n    public static void main(String[] args) {\n        A27RemoveElement a= new A27RemoveElement();\n        a.removeElement(new int[]{4,5},5);\n\n    }\n}\n```\n\n\n代码文件：\n[A27RemoveElement.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A27RemoveElement.java)\n\n### 总结\n\n- 顺序思路实现，优化了下小细节， 主要还是防脑袋秀逗。 思考思考，写写\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"A-leecode-手机号T9字母组合","url":"/2018/10/10/A_leecode_phone_num_combine/","content":"\n## 题目解析\n>Example:\n>Input: \"23\"\n>Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n>Note: Although the above answer is in lexicographical order, your answer could be in any o\n<!-- more -->\n\n\n思路方法和代码演示：\n```java\n/**\n * Created by dylan on 2018/3/22.\n * 电话号码的组合\n * 分析思路 比如输入123 实际是输入12的结果加上和3对应的组合\n */\npublic class A17PhoneCombine {\n\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<String>(); //字母组合结果\n        if (digits == null || digits.length() == 0) {\n            return result;\n        }\n\n        Map<Character, String> dict = new HashMap<Character, String>(); // 初始化拨号T9键盘字典\n        dict.put('1', \"\");\n        dict.put('2', \"abc\");\n        dict.put('3', \"def\");\n        dict.put('4', \"ghi\");\n        dict.put('5', \"jkl\");\n        dict.put('6', \"mno\");\n        dict.put('7', \"pqrs\");\n        dict.put('8', \"tuv\");\n        dict.put('9', \"wxyz\");\n        dict.put('0', \" \");\n        for (char tmp : digits.toCharArray()) {// 循环1\n            String val = dict.get(tmp);\n            if (val == null) {\n                return new ArrayList<String>();\n\n            }\n            List<String> tmpArray = new ArrayList<String>();\n            for (int i = 0; i < val.length(); i++) {//循环1 的结果result 和 当前tmp数字对应字母组合的处理逻辑\n                if (result.size() == 0) {\n                    result.add(\"\");\n                }\n                for (String item : result) {\n                    tmpArray.add(item + val.charAt(i));\n                }\n            }\n            result = tmpArray; // 更新当前循环的结果数组\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        A17PhoneCombine a17PhoneCombine = new A17PhoneCombine();\n        System.out.println(a17PhoneCombine.letterCombinations(\"123\"));\n\n\n    }\n}\n\n```\n\n代码文件：\n[A17PhoneCombine.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A17PhoneCombine.java)\n\n### 总结\n\n- 回溯上次处理结果，类似问题还有排列组合\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"A-leecode-反转整数[ReverseInteger]","url":"/2018/09/03/A_leecode_reverseInt/","content":"\n## 题目解析\n>Given a 32-bit signed integer, reverse digits of an integer.\n>''' example: 1234->4321\n>'''\n<!-- more -->\n\n反转一个整数\n\n## 分析步骤\n1、整数的反转比起字符串因为整数的特性，思路少许不一样\n\n代码演示：\n```java\n/**\n * Created by dylan on 2017/5/22.\n * 翻转整数和翻转数据串可以用不一样的思路， 因为整数的特性\n */\npublic class A7ReverseInteger {\n    public int reverse(int x) {\n        long i = 0; // 注意整数反转可能越界\n        while (x != 0) {\n            i = i * 10 + x % 10; // 末尾进位\n            x = x / 10; //移除掉末尾\n        }\n        if (i > Integer.MAX_VALUE || i < Integer.MIN_VALUE) {\n            i = 0;\n        }\n        return (int) i;\n    }\n}\n\n```\n\n\n代码文件：\n[A7ReverseInteger.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A7ReverseInteger.java)\n\n### 总结\n\n- 主要是每次余数作为高位，性能可以再考虑下\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"心志","url":"/2018/08/07/20180807/","content":"\n## 心志\n权当修炼， 炼心志。 学习和事业也需要这个\n“人之气质，由于天生，本难改变，惟读书可以变化气质，古之精相法者，并言读书可以变换骨相，欲求变化之法，总须先立坚卓之志”\n","tags":["心情","日记"],"categories":["其他"]},{"title":"海纳百川，有容乃大；壁立千仞，无欲则刚","url":"/2018/07/19/20180719/","content":"\n## 海纳百川，有容乃大；壁立千仞，无欲则刚\n林则徐任两广总督\n","tags":["心情","日记"],"categories":["其他"]},{"title":"漫漫长路，半程风雨，半程春","url":"/2018/05/09/20180509/","content":"\n## 漫漫长路，半程风雨，半程春\n我喜欢风雨中的春\n","tags":["心情","日记"],"categories":["其他"]},{"title":"清明时节","url":"/2018/04/04/20180327/","content":"\n## 清明时节雨纷纷\n不仅下雨了，北京还下雪了~\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-两排序数组的中位数","url":"/2018/03/22/A_leecode_median_two_sorted_arrays/","content":"\n## 题目解析\n>给出两个排好序的数组，找出合并后的中位数。很基础，组合排序的中间流程，我面试候选者有时会考察这个题目\n<!-- more -->\n\n\n\n## 分析和思路方法\n1、中位数为奇偶两类场景\n2、输入两数组已排好序， 找到合并后（m+n）/2 或者 （m+n+1）/2 位置的数。 但是不需要使用合并新空间\n3、两个数组同时遍历 查找其M=（m+n）/2 或者 （m+n+1）/2位置的数\n\n\n代码演示：\n```java\n/**\n * 很基础，组合排序的中间流程，我面试候选者有时会考察这个题目\n * 注意代码段和方法拆分， 这样可读性更强\n */\npublic class A4MedianOfTwoSortedArray {\n    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int la = nums1.length;\n        int lb = nums2.length;\n        if (la == lb && lb == 0) {\n            return 0;\n        }\n        if ((la + lb) % 2 == 0) {\n            int m1 = (la + lb) / 2;\n            int m2 = m1 + 1;\n            return (findM(nums1, nums2, m1) + findM(nums1, nums2, m2)) * 1.0 / 2.0;\n        } else {\n            return findM(nums1, nums2, (la + lb + 1) / 2);\n        }\n    }\n\n    /**\n     * size(a) >size(b)\n     *\n     * @param a\n     * @param b\n     * @param m m<=size(a+b)\n     * @return\n     */\n    private static int findM(int[] a, int[] b, int m) {\n        int la = a.length;\n        int lb = b.length;\n        int counter = 0;\n        int t1 = 0, t2 = 0;\n        int result;\n        while (true) {\n            if (t1 == la) {\n                result = b[t2];\n                t2++;\n            } else if (t2 == lb) {\n                result = a[t1];\n                t1++;\n            } else if (a[t1] <= b[t2]) {\n                result = a[t1];\n                t1++;\n            } else {\n                result = b[t2];\n                t2++;\n            }\n            counter++;\n            if (counter == m) break;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(findMedianSortedArrays(new int[]{1, 3, 5, 6}, new int[]{2, 7, 9, 10}));\n    }\n```\n\n\n代码文件：\n[A4MedianOfTwoSortedArray.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A4MedianOfTwoSortedArray.java)\n\n### 总结\n\n- 无他，良好习惯，代码片段方法抽离\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"冬天","url":"/2018/03/09/20180309/","content":"\n## 北京的冬天\n\n2018 市区还没下一场雪 \n","tags":["心情","日记"],"categories":["其他"]},{"title":"A-leecode-最长回文子串问题","url":"/2018/01/29/A_leecode_longest_palindrome_substr/","content":"\n## 题目解析\n>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n<!-- more -->\n\n\n\n## 分析\n1、回文串的定义为字符串为轴对称例如 \"aba\" \"aa\" \"a\" 都可以称为回文串\n2、题目找出目标串中最长的回文子串长度\n\n思路方法\n### 方法一\n首先想到的是穷举法,也是最基本的编码思路的体现。考虑到回文的场景可能为奇数或者偶数场景。\n- 回文判定函数[i,j] 判定数组的i到j位回文串\n- 从m开始遍历 m ∈ [0,length-1],采用中分方式， 按照奇偶两类情况查找\n\n代码演示：\n```java\n/**\n    * 找所有， 中分方式\n    *\n    * @param s\n    * @return\n    */\n   public String longestPalindrome(String s) {\n       if (s == null) return null;\n       if (s.length() == 1) return s;\n       char[] array = s.toCharArray();\n       if (s.length() == 2) {\n           if (array[0] == array[1]) {\n               return s;\n           } else {\n               return s.substring(0, 1);\n           }\n       }\n       int start;\n       int end;\n       int max = 0;\n       int result1 = 0;\n       int result2 = 0;\n\n       for (int i = 0; i < array.length; i++) {// 奇数情况\n           start = i;\n           end = i;\n           while (start >= 0 && end < array.length) {\n               if (array[start] == array[end]) {\n                   if ((end - start + 1) > max) {\n                       result1 = start;\n                       result2 = end;\n                       max = end - start + 1;\n                   }\n                   start--;\n                   end++;\n               } else {\n                   break;\n               }\n           }\n       }\n       for (int i = 0; i < array.length - 1; i++) {//偶数情况\n           start = i;\n           end = i + 1;\n           while (start >= 0 && end < array.length) {\n               if (array[start] == array[end]) {\n                   if ((end - start + 1) > max) {\n                       result1 = start;\n                       result2 = end;\n                       max = end - start + 1;\n                   }\n                   start--;\n                   end++;\n               } else {\n                   break;\n               }\n           }\n       }\n       return s.substring(result1, result2 + 1);\n   }\n```\n\n### 方法二\n在方法1的穷举法上可以这样思考,最长回文串长度不会超过n（length）, 那么我们可以按照长度n-- 来找。思路较方法1,最坏情况如果长度为1,代价同方法1 全部遍历\n- i,i+n-1\n- 先找长度为n的回文子串，再找n-1长度的,如果找到了退出查找， 即为结果。\n\n代码演示：略\n\n### 方法三\n思考到方法1中其实有很多重复判定,如果知晓r[i+1]\\\\[j-1]标识数组i+1到j-1位置的子串为回文串,如果a[i] == a[j]条件下 r[i]\\\\[j]也为回文子串,且长度+2.那么首先想到的就是动态规划,先确定状态转移方程.\n需要注意初始条件和遍历条件，这两者取决于转移方程的推导思路.\n- a[] 标识原始串数组。r[i]\\\\[j]标识源串从i到j为回文串\n- a[i]=a[j] 并且r[i+1]\\\\[j-1]为回文串， 那么新结果为i+1,j-1的结果长度+2\n- 状态转移方程决定初始条件和遍历条件, 初始条件为a[i]\\\\[i]=1,遍历条件可以是 i从length-1 开始 i--, j从i+1开始j++.\n\n代码演示：\n```java\n     /**\n     *  方法一  动态规划， result[i][j] 表示 i->j为回文串\n     *  那么 array[i]=array[j] 并且result[i+1][j-1]为回文串， 那么新结果为长度+2\n     * @param str\n     * @return\n     */\n    public static int maxSubStr(String str) {\n        char[] array = str.toCharArray();\n        if (array.length <= 1) {\n            return array.length;\n\n        }\n        int size = array.length;\n        int[][] result = new int[size][size];\n        int max = 1;\n        for (int i = size - 1; i >= 0; i--) { // 注意 遍历的方式和初始条件取决于 状态转移方程。需要利用到之前计算出的结果。\n            result[i][i] = 1;\n            for (int j = i + 1; j < size; j++) {\n                if (array[i] == array[j]) {\n                    if (j == i + 1) { // 偶数个数初始场景\n                        result[i][j] = 2;\n                      } else {\n                        if (result[i + 1][j - 1]>0){\n                          result[i][j] = result[i + 1][j - 1] + 2;\n                        }\n                      }\n                }\n                if (result[i][j] > max) {\n                    max = result[i][j];\n                    System.out.println(String.format(\"index,i=%d,j=%d, max=%d\", i, j,max));\n                }\n            }\n        }\n        return max;\n    }\n```\n\n### 方法四\n回文串特点是反过来也是它本身,那么最长回文子串问题实际就是源串和源串翻转串的最长公共子串问题\n但是需要排除掉某些场景\"abc123cba\"和\"abc321cba\",可以最长公共子串加上是否回文判定就行\n- LCS问题+回文判定\n\n代码演示：\n\n代码文件：\n[C9MaxPalindromeSubStr.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C9MaxPalindromeSubStr.java)\n[C5LCS.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C5LCS.java)\n[A5LongestPalindromeStr.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A5LongestPalindromeStr.java)\n\n### 总结\n\n- 避免重复计算判定，保存中间结果，符合动态规划条件之一\n- 状态转移方程如何推导和编写\n- 存在转移关系, 知晓i+1,j-1结果，那么i,j的结果可以推导出来，条件二\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"spark安装","url":"/2018/01/15/spark_01_install/","content":"\n## 安装\n下载安装地址官网：[http://spark.apache.org/downloads.html](http://spark.apache.org/downloads.html)\n好像这个没啥说的，一般getting start介绍的较为清楚，按照步骤流程一般不会有问题，所以着重写下遇到的问题点和补充。\n<!-- more -->\n关于 demo 例子语言问题， 有语言基础的推荐安装scala学习,另外python也是挺好的一种.\n\n## 问题点备注\n\n- 注意spark和scala版本匹配问题， 为啥scala会和python一样，版本不能向前兼容， 这是一个头疼的事情\n-\nto be continued...\n","tags":["spark"],"categories":["实时计算"]},{"title":"A-leecode-最大容量[MostContainer]","url":"/2018/01/14/A_leecode_most_container/","content":"\n## 题目解析\n>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn >such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, >such that the container contains the most water.\n>Note: You may not slant the container and n is at least 2.\n<!-- more -->\n\n给出一系列a(i),任意两个(i, ai) and (i, 0) 和x轴组成的u型矩形面积最大，u型的两边长度可能不一致，所装容量为短板边长决定\n\n\n## 分析\n1、决定u型桶高度的是短板\n2、决定面积的是x轴底边和上面所提到的短板边\n3、O(n)负复杂度来处理问题，上一情况下，最短边调整，才会可能出现面积较大的场景。 那么采用两边夹逼\n\n代码演示：\n```java\n/**\n * Created by dylan on 2017/9/21.\n * 两个边的构成一个矩形，为初始面积， 比它面积大的只可能是短边被替换，因为delta X变小，如果出现面积更大，只可能是比短边更长的边\n * 例如图例中最大面积为a2和a4组成的u型矩形 面积为2*2=4\n *               a3  \n *          a2   |    a4\n *     a1   |    |    |\n *     |    |    |    |\n *     ----------------\n */\npublic class A11MostContainer {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int left = 0;\n        int right = height.length - 1;\n        while (left <= right) {\n            int minHeight = height[left] < height[right] ? height[left] : height[right];//u型桶的短板， 最小竖边\n            int curr = (right - left) * minHeight;\n            max = max > curr ? max : curr;\n            if (height[left] < height[right]) { // 逻辑思路是最短边变化才会出现面积更大的u型桶\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max;\n    }\n\n\n    public static void main(String[] args) {\n      A11MostContainer a11MostContainer = new A11MostContainer();\n      System.out.println(a11MostContainer.maxArea(new int[]{1, 2, 3, 2}));\n    }\n}\n```\n\n\n代码文件：\n[A11MostContainer.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A11MostContainer.java)\n\n### 总结\n\n- 如果能想到这个思路，解题较简单， “逻辑思路是最短边变化才会出现面积更大的u型桶”。\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"冬天","url":"/2017/12/14/20171214/","content":"\n## 北京的冬天\n\n今年北京的冬天，雾霾次数少了很多\n","tags":["心情","日记"],"categories":["其他"]},{"title":"思考和表达的方式","url":"/2017/11/18/jiegouhua_slide/","content":"\n## 思考和表达的方式\n金字塔原理 读后感\n[点击查看](http://www.dylan326.com/2017/11/18/jiegouhua_slide/jiegouhua.pdf \"结构化思维\")\n","tags":["金字塔","slide"],"categories":["slide"]},{"title":"桂花香","url":"/2017/10/09/20171009/","content":"\n## 返京的第一天\n\n国庆回南方淡淡的桂花香， 一中的校园， 政府大院的小路，都是桂花香。\n","tags":["心情","日记"],"categories":["其他"]},{"title":"金字塔原理读书笔记","url":"/2017/09/30/jingzitayuanli/","content":"\n## 沟通\n听众是谁，他们想听到什么，他们希望如何听\n我该如何去表达\n\n自上而下表达，结论先行，以上统下\n自下而上思考，总结概括，归纳演绎\n\n演绎推导和归纳推导区别：\n演绎，三段式，需要存在逻辑关系，推论推导\n归纳，抽象出共同点，需要存在逻辑关系\n<!-- more -->\n## 摘要序言的方式\n背景：问题背景\n冲突：存在的冲突\n疑问：如何解决\n解答：可能解决\n\n## 思考的逻辑\n时间顺序\n结构顺序\n程度顺序\n总结需要避免使用缺乏思想的句子，说明结果和目标， 找出结论的共性\n\n## 界定问题\n切入点\n困扰\n现状\n期望结果\n答案\n疑问\n\n## 如何构建金字塔\n确定主题\n设想疑问\n给出答案\n引出疑问\n正式答案\n总结要点\n\n感想：自上而下表达，结论先行，以上统下；自下而上思考，总结概括，归纳演绎。\n需要实际当中去体会，实践， 演示文档、部门交流、上下级沟通、会议等等\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["读书笔记"],"categories":["读书笔记"]},{"title":"gperftools做堆外内存分析（案例JVM Inflater 内存泄漏分析）","url":"/2017/09/28/gperftools/","content":"\n## google-perftools\nperftools wiki地址 ：https://github.com/gperftools/gperftools/wiki\n安装perftools\n...\n工具主要作用分析程序：heap、cpu等，常用于c/c++程序分析\n使用文档如下：\nhttps://gperftools.github.io/gperftools/heapprofile.html\nhttps://gperftools.github.io/gperftools/heap_checker.html\nhttps://gperftools.github.io/gperftools/cpuprofile.html\n<!-- more -->\n## JVM堆外内存分析\n本文针对于 Oracle Hotspot jvm 虚拟机\nJVM 进程占用大小一般约等于： heap + perm + thread stack + nio directbuffer\n当然还有其他占用，一般情况来看native memory跟踪可以使用NMT参数 -XX:NativeMemoryTracking\n详情wiki ： https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html\nJVM常见内存泄漏检查方式可以按照 oracle提供的文档： http://www.oracle.com/technetwork/java/javase/memleaks-137499.html\n其中dbx是和perftools类似工具。\n\n除此之外\n进程内存在用在linux 面下top,pmap 等工具是较好确定进程内存的手段， 在/proc/${pid}/ 目录下smaps文件等查看RSS，虚拟内存，swap占用等。\npmap 找到内存申请的地址块， 可以使用gdb attach 后 dump 某一段的内存地址 ，后查看内存的数据。 注意gdb attach 进程会暂停， 线上谨慎操作。\n\n如果发现进程内存过高，可能需要注意下程序是否存在堆外内存泄漏问题，java进程出现的堆外内存泄漏常见有如下几个方面：\n- JNI\n- NIO directbuffer 泄漏\n- gzip  （本文案例就是此类）\n\n网络编程中程序中，nio directbuffer 有监控工具可以查看， directbuffer使用量、并且可以设置最大直接内存buffer。\n\n\n## JVM 进程使用perftools 做分析\n案例中发现的问题jetty 服务在某版本的JDK（jdk7u80~jdk8u045等 应该7u80后的版本在本文章编写时候都有）出现的内存泄漏问题分析和查找\n\n1、安装perftools 注意配置安装目录， 找到对应的文件路径\n2、启动java程序时候携带环境变量（可以参照 perftools wiki帮助 写的较为明确， 文档主要针对正对c/c++程序， Hotspot主要是c++写的）\nexport LD_PRELOAD=/opt/perftools/lib/libtcmalloc.so  # 安装后的库文件路径\nexport HEAPPROFILE=/opt/mybin.hprof  #heap分析文件路径和文件\n特别注意目录和文件权限是否是进程用户可使用的\n3、运行后启动程序后\n4、pprof执行程序（注意路径），分析这些heap文件 pprof --help查看使用方式\n./perftools/bin/pprof --text \\*.heap   以文本结果展示heap的分析文件， 结果说明见perftools wiki文档\n\n```shell\nTotal: 55838.9 MB\n 41320.8  74.0%  74.0%  41320.8  74.0% updatewindow\n  9018.8  16.2%  90.2%   9018.8  16.2% inflateInit2_\n  1559.4   2.8%  92.9%   1559.4   2.8% os::malloc@907260\n  1556.4   2.8%  95.7%   1556.4   2.8% init\n   587.5   1.1%  96.8%    587.5   1.1% 00007fb480508a66\n   551.4   1.0%  97.8%    551.4   1.0% 00007f2b1d6f4a66\n   451.5   0.8%  98.6%    451.5   0.8% 00007fb48177e8e9\n   183.1   0.3%  98.9%    183.1   0.3% 00007fb46c1b6c91\n   128.2   0.2%  99.1%    128.2   0.2% 00007fb480508245\n   120.4   0.2%  99.4%    120.4   0.2% 00007f2b1d6f4245\n   111.0   0.2%  99.6%   9129.7  16.4% Java_java_util_zip_Inflater_init\n   102.8   0.2%  99.7%    102.8   0.2% 00007f2b1e96a8e9\n    74.2   0.1%  99.9%     74.2   0.1% readCEN\n    45.8   0.1% 100.0%     45.8   0.1% 00007f2b09392c91\n     7.5   0.0% 100.0%      7.5   0.0% 00007fb4805025b6\n     4.5   0.0% 100.0%      4.5   0.0% 00007fb48192162d\n\t\t ......\n```\n\n对于上述问题表现的jdk1.7.0_76不会出现\njdk1.7.0_80,jdk1.8.0_45以上明显出现。\n用过pmap分析过 主要都是64m内存块较多， 查看过数据都是jar load相关的数据当时没引起注意\n分析主要在updatewindow，Java_java_util_zip_Inflater_init ， 这个是gzip相关， 于是搜索相关资料\n结论如下：\n'''Note that the URLClassLoader was properly disposed of, with a call to close() first, and that the ServiceLoader's reload() method was also called to flush it's internal cache.\nThis is NOT specific to the ServletContainerInitializer, it happens with any class that is loaded via the ServiceLoader.\nFile handles remain to the \\*.jar until the app's process is stopped.'''\n\n\n网上查找相关资料\njdk 问题  http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8156014\njetty issue https://github.com/eclipse/jetty.project/issues/231\n\n\n\n处理方法,以下其一\n- JDK降级到jdk7u76， 使用不会出现问题的JDK版本\n- 等新版本jdk bug修复\n- jetty contributer 给出的方案 disable url caching  wiki https://github.com/eclipse/jetty.project/issues/575\n\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java","memory"],"categories":["JDK"]},{"title":"A03-常见数据结构","url":"/2017/09/22/A03_shujujiegou/","content":"TODO。。。\n## 常见数据结构分类\n特点\n-\n-\n<!-- more -->\n\n代码演示：\n```java\n\n\n```\n\n\n\n代码文件：[C7QuickSort.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C7QuickSort.java)\n\n### 总结\n-\n-\n-\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","数据结构"],"categories":["算法"]},{"title":"A-leecode-两数和[Two Sum]","url":"/2017/09/22/A_leecode_sum2/","content":"\n## 题目解析\n>Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n>You may assume that each input would have exactly one solution, and you may not use the same element twice.\n>''' example:\n>Given nums = [2, 7, 11, 15], target = 9,\n>Because nums[0] + nums[1] = 2 + 7 = 9,\n>return [0, 1].\n>'''\n<!-- more -->\n\n整型数组中，找出两个数（不能是同一个元素），满足他们的和是给定的target值。 假设有唯一一组解。\n这个假设简化了结果输出条件，和代码边界逻辑。 实际问题中记住尽可能的去考虑这些条件和情况。\n\n## 分析步骤\n1、直接给出两数的所有和，和目标值相等的返回这两个数的索引值\n2、步骤1太直接了， 大部分人都这样说。 但我们为什么不能先写出来，再分析问题点， 可以从哪些方面去优化处理\n3、实现和分析见code\n\n代码演示：\n```java\npublic class A1Sum2 {\n\n    /**\n     * 直接思路方法\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int[] a1Sum2Method1(int[] nums, int target) {\n        int[] result = new int[]{0, 0};\n        for (int i = 0; i < nums.length - 1; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if ((nums[i] + nums[j]) == target) {\n                    result[0] = i;\n                    result[1] = j;\n                    return result;\n                }\n            }\n        }\n        return result;\n    }\n\n\n    public static int[] a1Sum2Method2(int[] nums, int target) {\n        int[] result = new int[]{0, 0};\n        Map<Integer, Integer> tmp = new HashMap();\n        for (int i = 0; i < nums.length; i++) { // 空间换时间。存储值和索引对应关系\n            tmp.put(nums[i], i);\n        }\n\n        for (int i = 0; i < nums.length - 1; i++) {\n            Integer j = tmp.get(target - nums[i]);\n            if (j != null && j != i) { // 去除掉 自己的判定\n                result[0] = i;\n                result[1] = j;\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(a1Sum2Method1(new int[]{2, 3, 5}, 5)));\n        System.out.println(Arrays.toString(a1Sum2Method2(new int[]{2, 3, 5}, 5)));\n    }\n}\n\n```\n\n\n代码文件：\n[A1Sum2.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/apus/A1Sum2.java)\n\n### 总结\n\n- 有些问题在条件容许的情况下可以思考出直接的方式，\n- 空间换取时间问题：类似如 整型数据数组中连续子串求和为指定值的个数等\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","leecode"],"categories":["算法"]},{"title":"哈尔滨","url":"/2017/09/19/20170919/","content":"\n## 今天校招面试的第一天 来到哈尔滨这座城市\n\n1、没有想象的那么冷， 可能现在的月份问题  \n2、不知道有什么特产，红肠么， 是否带点回家\n<!-- more -->\n3、高铁上读了金字塔原理， 证书一半的章节，总结在自己的笔记上\n4、计划回程，阅读下半章节 -- 演示逻辑\n5、伴随着校招面试，自己也在刷下题目， 常运转的机器不秀逗， 哈哈\n6、每天 “比不” 保持联系\n","tags":["心情","日记"],"categories":["其他"]},{"title":"Raft简介 slide show","url":"/2017/09/06/raft_slide/","content":"\n## Raft简介演示文档和介绍\n\n[点击查看](http://www.dylan326.com/2017/09/06/raft_slide/Raft.pdf \"Raft\")\n","tags":["slide","raft"],"categories":["slide"]},{"title":"国画","url":"/2017/08/24/20170824/","content":"\n## 国画\n\nPP\n<!-- more -->\n![国画](20170824/guohua.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A02-快速排序","url":"/2017/08/12/A02_kuaisupaixu/","content":"\n## 特性\n快速排序特点\n- 非稳定排序\n- 分治模式：那么就存在拆分和组合\n\n<!-- more -->\n## 快速排序步骤\n\n- 分治思想，那么源数组每层递归逻辑为：一分为二、对子问题同样方式处理\n- 选取枢纽元素（枢纽元素的选取决定有多种快速排序的实现方式）\n- 找到枢纽元素在数组中的位置（此处找位置的方法可以多种）\n- 对枢纽元素左边，右边做类似处理\n- 递归退出，数据已排好序\n\n代码演示：\n```java\n/**\n * 快速排序， 举例为升序\n *\n * @param a\n * @param m\n * @param n\n */\npublic static void quickSort(int[] a, int m, int n) {\n    if (m < n) {\n        int i = m;\n        int j = n;\n        int pivot = a[m];  // 枢纽元素为当前层级的数据第一个元素\n        while (i < j) {\n            while (i < j && a[j] > pivot) { // 找到右边第一个小于等于（取决升序还是降序）pivot的位置j，或者i=j\n                j--;\n            }\n            while (i < j && a[i] <= pivot) {// 找到左边第一个大于pivot的位置j，或者i=j。此处=由于选取的m作为枢纽，从m之后开始处理\n                i++;\n            }\n            if (i < j) { // i<j 交换ij位置的值，继续按此方法循环找ij位置\n                swap(a, i, j);\n            }else if(i==j){ // i=j找到了pivot的位置， 此位置的元素不会大于pivot\n                swap(a, m, i);\n            }\n        } // 以上定位到枢纽元素pivot的索引位置i。找到后固定改位置，对i左边和右边的同样方法处理\n        quickSort(a, m, i - 1);\n        quickSort(a, i + 1, n);\n    }\n}\n\n/**\n * 交换函数\n *\n * @param a\n * @param i\n * @param j\n */\nprivate static void swap(int[] a, int i, int j) {\n    int tmp = a[i];\n    a[i] = a[j];\n    a[j] = tmp;\n}\n```\n\n\n\n代码文件：[C7QuickSort.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C7QuickSort.java)\n\n### 总结\n- 初始条件\n- 选取枢纽元素，找到枢纽元素安置的位置\n- 对枢纽元素的前面部分，后面部分分别进行快速排序\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","排序"],"categories":["算法"]},{"title":"花儿一枚","url":"/2017/08/08/20170808/","content":"\n## 立秋后的第一天\n\n立秋，花儿一枚\n<!-- more -->\n![花儿一枚](20170808/20170723_193100.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"A02-堆排序","url":"/2017/08/06/A02_duipaixu/","content":"\n## 堆\n\n堆数据结构的特性\n>数组表示（节点x；左子节点2x；右子节点2x+1）\n完全二叉树、最后一层左子树开始填写\n最大堆、最小堆定义：除了根节点最大或者最小，其他子节点不会大过（不会小于）父节点的值  \n\n利用最小堆、最大堆得性质,逐步移除根节点，那么结果则为已排序数据。\n举例数据：\n```java\n{4,1,3,2,16,9,10,14,8,7}\n```\n<!-- more -->\n\n### 构建堆（大根堆）\n堆排序分为如下几个步骤 a~f\n- a) 数据数据堆表示\n- b) 自底向上，数据7的父元素i（i--）维持最大堆特性\n- c)~e) 按照对特性，循环保持\n- f) 完成后的最大堆\n![构建堆](A02_duipaixu/buildheap.jpg)\n\n\n### 堆排序\n- 构建最大堆（对应升序排列）\n- 从堆长度位置（数组尾部）开始遍历\n- 交换A[i]与A[1]; 堆长度减一，因为交换前A1为最大元素\n- 调整堆保持最大堆特性：adjust(A,1)。每次调整的代价为O(lg(n))\n- i=2 退出循环，得到升序数组。 那么时间复杂度为n*O(lg(n))\n上述流程的过程图如下\n![堆排序](A02_duipaixu/heapsort.jpg)\n\n\n### 总结\n- 初始化堆，即构建\n- 维持堆特性，主要包含上浮、下沉操作\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","排序"],"categories":["算法"]},{"title":"A01-递归式-台阶走法","url":"/2017/07/22/A01_taijie_n/","content":"问题\n>n个台阶走法问题， 已知可以一次一个台阶，一次两个台阶，一次三个台阶。 那么n个台阶有多少种走法？\n\n问题分析步骤\n1. n个台阶的走法为n-1个台阶走法+1，1=走一个台阶\n2. 最后一步的走法可以是题目中的三类\n3. 那么最后的结果必然是，最后的方案是一步、两步、或者三步，走法的和即为结果\n4. 最小边界， 只有一个台阶，两个台阶，三个台阶\n\n```java\npublic static int nTJ(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n            return 2;\n        }\n        if (n == 3) {\n            return 4;\n        }\n        if (n > 3) {\n            return nTJ(n - 1) + nTJ(n - 2) + nTJ(n - 3);\n        }\n        return 0;\n}\n```\n\n代码:[C6nTJ.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C6nTJ.java)\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","递归"],"categories":["算法"]},{"title":"A01-递归式-全排列","url":"/2017/07/22/A01_quanpaileidigui/","content":"\n全排列递归：[链接页面](http://www.dylan326.com/2017/06/23/quanpailie_digui/)\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","递归"],"categories":["算法"]},{"title":"A01-递归式","url":"/2017/07/21/A01_diguishizi/","content":"\n## 背景\n\n讲述了三种方法来推导出递归式\n>代换法(数学归纳法)\n>递归树\n>主方法\n<!-- more -->\n\n### 代换法\n\n代换法分如下两步\n- 猜测解的形式\n- 数学归纳法找出解的正确有效常数\n\n\n\n### 递归树\n\n画一个递归树，每个节点都表示递归函数调用集合中额一个子问题的代价；把每一层代价相加得到每一层代价的集合，再把每层代价相加，得到所有层次的总代价。递归式表示分治算法的运行时间的时候，递归树的方法效果更加明显。\n\n\n### 主方法\n先看下主定律的定义：令a≥1和b>1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式 T(n) = aT(n/b) + f(n)。\n这个也是我们推导出递归式的主要方法，代换法、递归树相对为辅助。\n主定律a个子问题每个子问题的时间复杂度为T(n/b)，划分问题和合并子问题答案的代价为f(n)。\n主定律公式包含三种条件，并非对所有的f(n)都成立。仅当满足次三类条件的才能使用主定律推导。\n\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","递归式子"],"categories":["算法"]},{"title":"A00-Algorithms导论系列","url":"/2017/07/17/A00_daolun/","content":"\n## 背景\n\n最近总结下来想写一系列文章的专栏，先从算法导论入手， 巩固下基础知识体系，避免大脑秀逗。计划大概半年多时间抽炼出常见内容的系列大纲笔记，供记录和学习， 如有需要指正地方望邮件交流。\n\nleecode 算法题目主要也是锻炼思考\n\n```python\nprint 'life and world'\n```\n\n<!-- more -->\n\n## 简明摘要  \n一、基础部分\n>1.NP完全理论  \n- P：所有可以在多项式时间内求解的判定问题构成P类问题\n- NP：所有的非确定性多项式时间可解的判定问题构成NP类问题\n- NPC：NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)  \n2.递归式  \n给出了递归式推导的三种方法  \n- 代换法：数学归纳，根据规律推测出递归式  \n- 递归树：分治时间复杂度的尤其适合递归树推算  \n- 主定理公式：定理4.1(主定理)    令a≥1和b>1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式 T(n) = aT(n/b) + f(n)  \n3.概率分析与随机算法  \n- 随机算法，不依赖输入，输出和输入无关  \n\n二、排序算法与顺序统计  \n>1.堆排序\n- 堆：完全二叉树\n- 大根堆，ASC排序  \n2.快排序\n- piovit 枢纽元素x，p r对x比较 。回归x到正确位置。对左边的QS；对右边QS  \n3.线性时间排序\n- 计数，确定数x在第几个位置\n- 基数，0~9依次排序。 稳定\n- 桶排序，均匀分布的放在排序号的桶，对桶中元素进行排序  \n4.中位数与顺序统计学  \n\n三、数据结构  \n>1.栈与队列\n- 特性\n- 可以相互转化  \n2.链表\n- 单向链表；表头；表尾\n- 双向链表、带哨兵的环形双向链表（哑对象dummy）  \n3.散列表\n- 散列函数：除法、乘法、全域散列\n- 链表法、开放地址法（双重散列）\n- 简单一致散列假设  \n4.二叉查找树\n- 节点x， x左子树最大不超过x；x右子树最小不小于x\n- 节点x：value，left、right、parent    \n5.红黑树\n- 二叉查找树、平衡特性\n- 根节点 黑色；节点或红或黑；叶子节点黑色（nil节点也称哨兵节点）\n- 红节点的两个儿子都是黑节点\n- 每个节点开始，到其子孙节点的所有路径上包含的黑节点个数相同  \n\n四、高级设计  \n 1.动态规划\n 2.贪心算法\n 3.平摊分析\n\n五、高级数据结构  \n1.B树：\n\n六、图算法  \n 1.图基本算法\n 2.最短路径、最小生成\n\n七、算法研究  \n 1.数论相关算法\n 2.字符串匹配\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","Algorithms"],"categories":["算法"]},{"title":"小记窗台多肉","url":"/2017/07/17/20170717/","content":"\n## 窗台多肉\n\n就像照顾孩子一样\n<!-- more -->\n![多肉](20170717/20170716_164909.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"全排列问题-字典序","url":"/2017/07/06/quanpailie_permutation/","content":"\n## 分析\n\n上一篇是全排列的递归解法，现在按照字典序的解法处理：\n\n> 1,2,3\n>\n> 1,3,2\n\n> > 给出一个数字排列的最小字典序，找到他的下一个字典序， 直到到达最大字典序值\n\n1,2,3->3,2,1 中间的过程即为全排列的过程\n\n<!-- more -->\n\n#### 字典序含义\n\n从左到右按照位置比较，按照依次增大的顺序排列，例如123，12，21，1，2。的字典序排序后是1，12，123，2，21。\n\n#### 下一个序列\n\n> 1、从右到左，找到第一个邻位递减的数a\n>\n> 2、找a右边比自己大的，最接近自己的数b\n>\n> 3、交换a,b位置\n>\n> 4、 对b右边的数字从小到大排列，即找到字典序的下一个序列\n\n以数字举例:746532,步骤：\n\n1、找到第一个邻位递减46中的4\n\n2、找到比4大的最小数5\n\n3、交换4，5。即：756432\n\n4、5右边数据排序，即：752346\n\n746532下一个序列就是752346\n\n## 编码思路\n\n代码及注解\n\n```java\n    //{1,2,6,5,4,3,0}\n    public static int[] nextOrder(int[] a) {\n        int flag = -1;\n        int index = 0;\n        for (int i = a.length - 1; i > 0; i--) { //找到第一个邻位递减的， 记录位置index\n            if (a[i] > a[i - 1]) {\n                flag = a[i - 1];\n                index = i - 1;\n                break;\n            }\n        }\n\n        if (flag == -1) { // 没找到下一个， 直接返回自己\n           /* for (int i = 0, j = a.length - 1; i < j; i++, j--) {  // 注释部分表示没有下一个 从头开始\n                swap(a,i,j);\n            }*/\n            return a;\n        }\n\n        int delta = Integer.MAX_VALUE;\n        int indexSwap = 0;\n        for (int i = index + 1; i < a.length; i++) { // 找到index之后第一个比index位置值大的索引位置indexswap\n            if (a[i] > flag && (a[i] - flag) < delta) {\n                delta = (a[i] - flag);\n                indexSwap = i;\n            }\n        }\n\n        swap(a, index, indexSwap); // 交换 index  indexswap 两索引位置的值\n        sortIncr(a, index + 1, a.length); // 对index 之后的位置升序排列\n        return a;\n    }\n```\n\n全排列：[C2DicOrder.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C2DicOrder.java) [C3Permutation.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C3Permutation.java)\n\n------\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","全排列"],"categories":["算法"]},{"title":"公园小车","url":"/2017/07/06/20170706/","content":"\n## 旧事记录\n<!-- more -->\n![小车](20170706/1_18_WP_000098.jpg)\n","tags":["心情","日记"],"categories":["其他"]},{"title":"脑子vs嗓门","url":"/2017/07/03/20170703/","content":"\n## 记录工作一件事\n\n上帝给了人们脑子，但有些人偏要用嗓门—哈哈 dylan\n","tags":["心情","日记"],"categories":["其他"]},{"title":"纪念日","url":"/2017/06/23/纪念日2017/","content":"\n## 纪念日\n\n> 今天是我们领取结婚证的一周年纪念日。 我知道那份证书的分量，是她对自己一生的托付，给我；是我与她携手到老的启程见证。\n>\n> > 今天看到了许多历经大半百的老人，或形单，或配对，或不认识但能唠上嗑，或许有着共同的言语。耳朵听话不清，走路也慢慢的，有的是轮椅。 \n> >\n> > > 我想到：在一起度过半百是一件多么幸福的事情。\n\n","tags":["心情","日记"],"categories":["其他"]},{"title":"全排列问题-递归","url":"/2017/06/23/quanpailie_digui/","content":"\n## 分析\n\n全排列是一个常见的算法逻辑题，对于例子{1,2,3}来说它的全排列：A33=6个，枚举结果如下：\n\n> 1,2,3\n>\n> 1,3,2\n>\n> 2,1,3\n>\n> 2,3,1\n>\n> 3,1,2\n>\n> 3,2,1\n\n> > 每个元素作为首位，剩下元素的全排列：\n\n这句话如何理解挺关键，是整个递归思路的总结，我们按照两个步骤来分析\n\n<!-- more -->\n\n#### 步骤1\n\n“剩下元素的全排列” 实际上就是一个递归的语句，它的结束条件是剩下元素只有一个元素了，那么前面的元素全部固定，和剩下的这个最后元素组成的结果就是全排列的一个序列。\n\n#### 步骤2\n\n>每个元素放置到首位\n\n元素作为首位，实际也存在一个递归的理解。 如例子中的1开头，剩余元素的子问题中，2也做过首位等。\n\n## 编码思路\n\n代码及注解\n\n```java\npublic static void printFullArray(int[] a, int start, int end) {\n        if (start == end) {\n            System.out.println(Arrays.toString(a)); // 打印数组\n        } else {\n            for (int i = start; i <= end; i++) {// start到end的全排列 数组索引位置\n                swap(a, start, i);// 从index=0开始交换。作为首位的元素\n                printFullArray(a, start + 1, end);//剩余元素的全排列\n                swap(a, start, i);// 数据需要复原；可以看某次递归深度的执行，即之后的每个元素交换到前面， 所以每次都是初始的复原位置开始\n            }\n        }\n\n    }\n```\n\n全排列递归：[C1FullArray.java](https://github.com/yangl326-Dylan/apus/blob/master/src/main/java/com/dylan326/justcode/C1FullArray.java)\n\n引申问题：元素存在相同如何处理 如{1,2,2,3}。加上判定，交换或者作为开头的元素是之前未处理过的。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["脑子秀逗","递归"],"categories":["算法"]},{"title":"AbstractQueuedSynchronizer实现分析","url":"/2017/05/15/aqs1/","content":"\n### 背景介绍\n\nJDK1.5开始的java.util.concurrent包（简称J.U.C包）提供了大部分同步器的构建源框架类：AbstractQueuedSynchronizer，简称AQS类。我们使用到的大部分同步器都会有一个实现了AQS的子类。\n\n<!-- more -->\n\n### 原理分析\n\n简单的理解，AQS类实现了两者\n\n1. 自动管理了一个int类型的state同步状态，CAS保证其原子性\n2. 一个阻塞、唤醒线程的队列管理，双向链表\n\n先从同步器基本讲起，一个同步器一般提供两种方法：一种是acquire；一种是release。acquire会阻塞线程调用或者非阻塞方式直接返回同步状态，release操作就是改变此同步状态，唤醒其他被阻塞的线程执行。\n\n例如：ReentrantLock的lock() /unlock()、CountDownLatch的await()/countDown()、Semaphore的acquire()/release()等都是上述两种的实现。只是每个实现子类中的state表达的同步状态有着自己的含义。注：FutureTask同步类中没直接使用AQS类，但基本的同步器设计思路同AQS。\n\n需要下面三个基本功能组件相互协作：\n\n- 一个具有原子性的同步状态\n- 线程的阻塞与唤醒\n- 队列的管理，支持排队或者闯入，即处理公平非公平\n\n##### 原子性状态\n\nAQS类提供了一个int类型的state状态（备注当然也提供long类型的state状态，实际情况下int满足绝大部分场景），通过state的读取和修改来表示不同的状态，修改基于atomic原子类中CAS（compareAndSet）源语等操作来维护这个状态。它在不同的同步器中表达的含义不一样，例如重入锁中，当某个线程从条件等待中返回，然后重新获取锁时，为了重新建立循环计数的场景就可以使用到这个状态。当然有些同步器中也可以不使用此状态。\n\n##### 阻塞\n\n说到阻塞当然会想到线程的wait和notify， 对比JUC中的的LockSupport类， 两者的区别是:LockSupport提供主动的唤醒机制，而notify则是抢占形式的唤醒模式。LockSupport的unpark方法支持主动唤醒某个线程，提供了相对于notify更优良的机制。\n\n##### 队列\n\n实际上AQS的本质就是一个阻塞线程队列的管理器，严格的FIFO（先入先出）备注：不支持优先级队列。它以类似自旋锁的自旋模式来判定现成的获取和释放。\n\n### 参考\n\n- AbstractQueuedSynchronizer类注释doc， 基本这个文档明白了，再加上一个实现类，基本每个同步类都会实现一个AQS的实现类作为内部类\n- Doug Lea大师（八字胡老爷爷）论文：[The java.util.concurrent Synchronizer Framework](http://gee.cs.oswego.edu/dl/papers/aqs.pdf \"The java.util.concurrent Synchronizer Framework\")\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java","JVM"],"categories":["语言","JDK"]},{"title":"什么是CheckSum校验和","url":"/2017/04/06/checksum/","content":"\n## 简介\n对于了解过TCP/IP协议的来说，会注意到部分协议头中的checksum字段，如TCP， IP等。那么checksum是什么、为什么被使用、如何计算出来， 对这些问题做一个简单的讲述。\n\n## 回顾\n\nIP头结构的理解，详见本本站一篇IP头的结构文章。简单的归纳就是32bit倍数的数据， 最大头长度位数数据是4bit-IHL（单位是4字节即32bit）那么最大15*32bit=60字节；最小无可选数据为20字节。  \n\n数据结构如下：  \n\n```shell\n    0                   1                   2                   3  \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n   |Version|  IHL  |Type of Service|          Total Length         |  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n   |         Identification        |Flags|      Fragment Offset    |  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n   |  Time to Live |    Protocol   |         Header Checksum       |  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n   |                       Source Address                          |  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n   |                    Destination Address                        |  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n   |                    Options                    |    Padding    |  \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n```\n\n我们看比较关注的几个字段:  \nHeader Checksum， header checksum占用16bit数据空间。  \nPadding：补充数据，确保为32bit的倍数，那么头数据肯定也是16bit的倍数。  \n其他字段本文暂且用不到，如需详细了解请看另一篇文章。\n\n## 定义及描述\n什么是checksum， 校验和是一个用来检测数据是否和原来一致的一个值， 它的位数16bit，根据数据计算出来的。因为数据在网络上传输存在误码或者错误，那么需要一个检测值在包头判定数据是否正确。  \n我们把包头数据按照16bit分组，然后对每组数据按位求和， 那么这个值可认为为校验和。\n\n## IP头checksum计算方式\n当发送端发送数据的时候，把checksum数据位置为0，IP头数据按照16bit分组计算出校验和值；接收端接收到的头数据同样按照16bit分组，计算出每组的反码并求和， 如果ip头在传输中不存在数据错误，那么计算结果应该全为1。\n## 总结及后记\n校验和是一种数据有效性的检测手段，优点对比MD5/CRC等是计算快速，缺点是并不能完全的保证数据的正确性， 需要应用协议或者程序去保证。 亚马逊S3某次故障中就出现内网传输数据bit错误导致的问题，所以应用层做数据校验。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["网络","TCP/IP"],"categories":["网络"]},{"title":"面试官感想","url":"/2017/03/03/xinqin20170303/","content":"\n## 最近面试\n\n今年年后最近面了好多人员，自己有一些准则：\n基本原则\n​\t优先考察考察基本能力、潜在能力，思考和学习能力。对应届生尤其重要\n掌握的知识面的宽广和相关知识面的深入程度。不过分的追求掌握的多少\n简历内容及所述符合实际，不实者慎重或不考虑\n相关内容由浅入深，专业性或者职位要求较强的，可有相关类型的考察\n语言表达、对待事情的态度、责任心等相关软素质\n\n面试注意事项\n​\t提前review候选人简历，做好相关面试准备，先有介绍，主要经历中贡献了什么，解决了什么。若考察风格没有太多的不妥，可按个人的风格考察，如遇到相关迟疑，可提示相关信息，看候选者的理解和分析能力，围绕候选者掌握情况，考察如何分析和处理相关问题\n\n不是知识，是搜索和学习知识的能力\n不是答案，是解决问题的思路和方法\n通过后给到下一面试官，不通过送走。做好相关面试记录\n","tags":["心情","日记"],"categories":["其他"]},{"title":"2017新年","url":"/2017/02/07/xinqin20170207/","content":"\n## 新的一年\n\n还是这句话给自己 be honest with yourself and then the world.\n","tags":["心情","日记"],"categories":["其他"]},{"title":"日常","url":"/2017/01/10/xinqin20170110/","content":"\n## 日常-早上出门\n\n每天早上出门，lp总说我穿的漂漂亮亮做什么，说！什么意图\n","tags":["心情","日记","日常"],"categories":["其他"]},{"title":"TCP Retransmit,TCP重传","url":"/2017/01/05/tcpip_1_kuaisuchongchuan/","content":"\n# TCP重传\n\n### 为什么要重传\n\nTCP需要保证数据包的可靠性送达，必须有重传机制  \n<!-- more -->\ntcp数据传输中syncnum和ack机制的单位是发送的字节数，那么如果1，2，3，4，5份数据发送过去，3出现丢失，收到4，5 那么数据该如何回复确认，ack机制只能确保确认最大的收到字节数，对于存在跳跃数据没法确认。\n### 超时重传\n\ntcp有多重定时器，其中重传定时器，处理超时重传,数据3投递存在丢失，等待ack超时后可以重传3数据。  \n### 快速重传\n\n鉴于超时重传取决于超时时间，快速重传的，快速相对于超时重传机制，实际可以理解为主动重传。例子同上，3接收丢失，收到4，5 仍旧回复2数据的ack， 那么发送方知道3丢失，重复传送3数据，此时接收方已收到4，5数据，收到3数据后回复5数据ack\n### 思考问题\n\n超时重传，tcp如何确认超时时间   \n快速重传，如果去优化连续数据中的若干部分段传输丢失，有何利弊。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["网络","TCP/IP","TCP重传"],"categories":["网络"]},{"title":"驾照","url":"/2016/10/11/xinqin20161011/","content":"\n## sign\n过完十一后的几天， 今天拿到驾照了，北京这边周期还挺短的，一个半月左右\n","tags":["心情","日记"],"categories":["其他"]},{"title":"Swallow size和Retained size区别（+ deep size）","url":"/2016/08/10/java_mem_size/","content":"\nJVM heap中对象大小有着如下大小表示\n-----------  \n\n如果对象存在其他引用，那么我们来描述对象大小有如下几种类型：\n\na)Swallow Size: 存储对象自身所包含的内存占用量\n\n1.仅表示对象自身  \n\n<!-- more -->\n\n2.集合等，对象自己和对象中元素或者域（fields)的“引用”的大小。只包含引用数据的大小   \n\n3.可以使用instrumentation.getObjectSize(obj)获取到大小\n\nb)Retained Size: 对象自身的swallow size加上此对象可达的所有对象的swallow size\n\n1.直接可达，间接可达  \n\n2.在GC树上，仅仅来自此对象，不包含其他引用（包括gc root reference）\n\n3.汇总理解就是此对象被垃圾收集器回收时候GC释放掉的内存大小\n\nc)Deep Size: 相比如上两种这类较为少使用，递归遍历class: fields+superclass 的swallow size总和\n\n### 参考\n\nJava Performance: The Definitive Guide\n\n大小计算方式：[Instrumentation Memory Counter](http://www.javaspecialists.eu/archive/Issue142.html \"Instrumentation Memory Counter\")\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java","JVM","heap memory"],"categories":["语言","JVM"]},{"title":"情绪","url":"/2016/08/03/xinqin20160803/","content":"\n## 情绪\n### 控制到情绪是多么困难的事情吗\n","tags":["心情","日记"],"categories":["其他"]},{"title":"TCP/IP卷1笔记大纲","url":"/2016/06/30/tcpip_1/","content":"\n# 协议卷1备注笔记\n\n## 四层网络应用模型\n\n1.应用层 ftp email telnet  \n2.传输层 TCP UDP  \n3.网络层 IP（ICMP IGMP）  \n4.链路层 设备驱动程序及接口卡（arp-地址解析协议 rarp-反地址解析协议）   \n传输层提供端到端， IP层提供点到点  \n\n<!-- more -->\n\n## 五类互联网地址\n\nA 0.0.0.0~127.255.255.255  \nB 128.0.0.0~191.255.255.255  \nC 192.0.0.0~223.255.255.255  \nD 224.0.0.0~239.255.255.255  \nE 240.0.0.0~247.255.255.255  \n\n\n\n## 域名系统DNS 实际为一个分布式数据库\n\n子网掩码 192.0.2.96/24表示的是一个前24位被用作网络号的IP地址（和255.255.255.000的意思一样）  \n计算方式是位与运算，如：\n类别\n起始位\n开始\n结束\n点分十进制掩码\nA  \n\n0\n\n0.0.0.0  \n\n127.0.0.0  \n\n255.0.0.0  \n\nB  \n\n10  \n\n128.0.0.0  \n\n191.255.0.0  \n\n255.255.0.0  \n\nC  \n\n110  \n\n192.0.0.0  \n\n223.255.255.0  \n\n255.255.255.0  \n\n### 封装与分用-封装\n\nTCP数据段（tcp segment）\nIP数据报文 （ip datagram）  \n以太网数据帧（frame）46~1500（字节 可设置）  \nIP头有一个8bit的协议域，标示协议类型1=ICMP 2=IGMP 6=TCP 17=UDP\n\n### 封装与分用-分用\n\n端口号：\n大部分知名端口号为奇数? 半双工历史  \ntcp 23  \nudp 53  \n\n### 环回接口\n\n国际惯例ip是127.0.0.1  并设置localhost\n\n### IP网际协议\n\nip不可靠性。  \nip无连接。 每个ip数据报文独立， 可以没有先后顺序  \n网络字节序：大端字节序  \nTTL 生存时间，一般为源主机设置  \n\n### ARP地址解析协议\n\nARP功能是IP地址和不同网络技术的硬件地址做一个映射。arp发出一个arp数据请求给每个以太网上的主机，对应主机符合后回复arp应答，发送ip报文到目标主机\nRARP 是许多无盘系统在引导时候获取ip地址的\n\n### ICMP 网络控制报文协议Internet Control Message Protocol\n\n常用于返回错误信息及分析路由，如 ping（icmp echo的request和reply） traceroute\n\nPING  \n不经过传输层，仅为ICMP的echo的request和reply\n\nIP分片  \nMTU 以太网硬件（网卡）一般设置为1500：例如：IP首20， UDP首8 剩余1472数据字节\n\n### 广播多播单播\n\n使用单播IP地址的IP传输方式，叫做IP单播（Unicast），简称为单播。  \n使用广播IP地址的IP传输方式，叫做IP广播（Broadcast），简称为广播。  \n使用组播IP地址的IP传输方式，叫做IP组播（Multicast），简称为组播。  \n广播不实际增加网络通讯量， 但是如ICMP协议端口不可达会额外引起广播流量  \n\n### IGMP internet组管理协议\n\n广播长局限于局域网中，多播协议可以降低不参与通讯的主机负担  \n\n### DNS域名系统\n\n一个基于tcpip的分布式缓存\n\n### TCP传输控制协议\n\n面向连接可靠地字节流服务  \n可靠性保障：  \n- tcp segment 数据块封装成ip协议发送  \n- 发送一个段后，启动一个定时器等待回复（自适应超时和重传）  \n- 收到发送端的数据后给一个确认的回复（不一定是立即回复）  \n- 首部和校验和来保证数据正确性  \n- ip数据报文到达可能无序， tcp对数据报文重排序交给应用层  \n- IP数据包会重复，需要丢弃重复  \n- 提供流量控制，接收端只容许发送端发送本段缓冲能接收的数据  \n\ntcp首部中有6个标示bit:  \n- URG 紧急指针  \n- ACK确认序号有效  \n- PSH 尽快发送到应用层  \n- RST 重新建立连接  \n- SYN 同步序号用来发起一个链接 （ISN 初始序列号，随机+数据包长度）  \n- FIN 发送完毕  \n\n三次握手：SYN n->SYN m、ack n+1->ack m+1  \n四次握手：FIN n、ack ->ack n+1->FIN m、ack ->ack m+1  \n\n链接主要状态：  \nS  : Listen=被动打开  \nC  : SYN_SENT=主动打开  \nSC: ESTABLISHED=链接建立  \nC  : FIN_WAIT=主动关闭  \nS  : CLOSE_WAIT=被动关闭  \nC  : TIME_WAIT=关闭等待  \nS  : CLOSED=关闭（假想）  \n\nNagle算法， 尽量的合并发送包，合并条件：  \n- 达到MSS（最大segment 大小） 大小 MSS来自MTU（包含IP和tcp或者udp头）  \n- FIN协议  \n- tcp nodelay（关闭 Nagle algorithm）  \n- 或者一段时间（200ms）超时  \n\n### 滑动窗口\n\n控制流量避免拥塞。 分为发送窗口和接收窗口  \n\n### 超时和重传机制\n\n定时器：  \n\n- 重传定时器  \n- 坚持定时器 使窗口大小信息保持流动  \n- 保活定时器  \n- 2MSL定时器 测量timewait时间  \n\n超时和重传： 指数避退策略  \n\n插口对（socket pair）套接字对， ip_port-r_ip_port  \nISN 初始序列号， 随机值  \n\nMSL（最大segment lifetime）  \nTIME_WAIT 为2MSL状态，在等待期内，这部分时间socket pair 不容许被使用  \n\n### 后记\n\n待续和完善， 目前简要备注大纲\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["网络","TCP/IP"],"categories":["网络"]},{"title":"机遇","url":"/2016/06/30/xinqin20160630/","content":"\n## 如此\n\n百尺竿头\n","tags":["心情","日记"],"categories":["其他"]},{"title":"领证了","url":"/2016/06/23/20160623/","content":"\n## D&E\n用老婆的话就是：\n>2016年06月23日，阴天微风，早上匆匆领个证，就各自回公司上班\n\n捂脸~\n","tags":["心情","日记","D&E"],"categories":["其他"]},{"title":"用户态和系统态区分","url":"/2016/06/08/kernel/","content":"\n# 介绍\n\n​    在操作系统中，有着分区域保护特性，也作保护环、或者CPU环，简称Rings。用来处理发生故障时候数据错误处理，及恶意操作处理。内层Ring可以使用外层Ring的任意资源。而外层需要请求权限才能访问内层资源。   \n​    在此基础上就区分了系统态（核心态）和用户态。每一个用户进程运行自己的代码存在在用户运行态，当调用系统函数的时候，运行模式转变为进入系统态。\n\n<!-- more -->\n\n# 系统态\n\n​    系统态在wiki百科上的解释:在处理器的存储保护中，核心态，或者特权态，又称之为内核态（与之相对应的是用户态），是操作系统内核所运行的模式。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。  \n# 用户态\n\n​    操作系统执行用户代码空间的运行形态。\n# 参考信息\n\n​    当一个进程执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为系统态）。\n\n​    此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。\n\n​    内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。\n\n​    Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。   \n\n# 总结\n\n操作系统运行的不同级别，导致有这两种运行形态的区分。cpu总处于以下状态中的一种：用户态即用户空间，系统态，两者间的切换。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["Socket","IO","kernel"],"categories":["网络","系统"]},{"title":"IO类型介绍","url":"/2016/05/05/socket_io/","content":"\n# IO分类\n\n按照《Unix网络编程》划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，\n\n按照POSIX标准来划分只分为两类：同步IO和异步IO。区分是一个麻烦事情，有相关的背景条件。  \nBIO（OIO）：同步阻塞IO  \nNIO：同步非阻塞IO，基于事件驱动模型的设计  \nAIO：异步非阻塞IO，也是基于事件驱动的设计，和NIO不一样的是在读写交互方式，采用异步或者回调的方式返回相关结果  \n\n<!-- more -->\n\n# 名词解释\n\n同步VS异步：同步和异步概念的角度是对于叙说对象来定义的，描述的是用户态和系统态的关系， socket的读写操作，是直接同步返回结果还是异步返回结果。  \n阻塞VS非阻塞：这个较好理解，阻塞住等待事情处理完毕还是处理其他事情。\n\n\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["Socket","IO"],"categories":["网络"]},{"title":"Raft协议算法简介","url":"/2016/04/12/raft/","content":"\n# Raft 协议算法简介\n\n## 简介\n\nRaft协议算法产生的结果和Paxos的效果相同，Raft算法设计较Paxos设计易懂，并且有着更好的生产环境的实现方式。\n\n<!-- more -->\n\n## 背景\n\n事务操作的四要素ACID：原子性、一致性、隔离性、持久性、 对于一个分布式环境的服务来说，较难满足一个事务的要求。比如对于一致性来说就是一个较难处理的问题，Raft正是为了解决分布式环境中一致性而产生的一种一致性协议算法。\n## Raft概念\n\n  1、Follower(追随者)角色  \n  2、Candidate(候选者)角色  \n  3、Leader(追随者)角色  \n  4、Term(时间阶段)  \n  5、server(或者node 泛指服务节点,算法中指log节点)\n## 基本背景\n\n  1、集群包含若干server（或者node），数目5是一个典型的分布式集群数目，对于这样一个系统来说，最多容忍的失败server个数为2（N>=2F+1)，总的服务数N， 容忍失败的个数F。  \n  2、所有的node在同一个时期（term）只会有以上三种角色状态的其中一种。  \n  3、Term是一个不定的时间长度，每个term最多只会有一个leader，可能没有。成功选举后由这个leader领导cluster直到term结束。  \n## Leader选举\n\n#### 选举流程\n\n  1、初始节点状态都是follower  \n  2、收不到leader 通知或者candidate请求（超时），开始触发选举流程  \n  3、F.增加自己的term num并转换为candidate状态（过程时间随机）  \n  4、F.投票自己并且发送给其他人“投我”的请求  \n  5、F.最终结果有三类：获得大多票数成为leader、其他f成为leader、无结果继续第二轮投票  \n#### 状态转换\n\nFollower->Candidate 开始选举  \nCandidate->Candidate 选举超时  \nCandidate->Leader 选举成功  \nCandidate->Follower 发现其他leader 或者新的term时期  \nLeader->Follower 发现其他leader 或者更好的term时期  \n## Log Replication\n\n### 协议针对log 副本。数据同步流程\n\n  1、client发送数据请求  \n  2、leader接收数据请求，其他角色接收到请求转给leader  \n  3、L.发出append请求（记录数据）  \n  4、L.收到大多数数据回复，返回client请求状态  \n  5、L.下个心跳把commit给到follower  \n  6、如果传输失败，leader可以不断重试  \n### 流程约定\n\n  1、log entry数据特性：log index、term num、commond  \n  2、log 持久化存储  \n  3、entry被大多数存储成功则为commited  \n  4、index和term相同那么之前的数据（entry）都是相同的  \n  5、某个commit之前的数据都是commited的  \n  6、append操作带上上一个的entry信息（index和term）并做检查  \n  7、检查不匹配，leader重试前一条。采用迭代重试方式直到完成   \n## 参考资料\n\nRaft协议特性简介\n参考资料：\n动画演示 http://thesecretlivesofdata.com/raft/  \nRaft官网 https://raft.github.io/  \n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","categories":["分布式系统"]},{"title":"Quorum一致性算法","url":"/2016/04/11/quorum_consensus_algorithm/","content":"\n## Quorum一致性算法简介\n\n### 背景\n\n一个组包含若干副本集合，个数为N。每个副本集合存储着items的集合，这个集合可以是文件或者内容，每个item有着唯一的标示和一个状态，我们称之为NWR问题。\n\n<!-- more -->\n\n### 定义\n\nR：定义R为读的最小票数，W：定义为写的最小票数。N为副本个数。  \n每个副本集存储着同一个item的不同的版本号码，越大的版本号标示这个数据是最近的。  \n读的个数是对写的个数感兴趣的，因为读到的数据应该是大多数写成功的结果。  \n### 公式\n\nR+W>N;读写的票数和应该大于总的副本集数（节点数）  \nW>N/2;写的票数应该大于一般的副本集数（节点数）  \n### 举例\n\n对于一个三个副本集组，有着如下的可能：  \nR=3,W=1:这个有着高效的写性能，但是昂贵的读数据开销，对于读较多的场景，这种尤其较为糟糕。并且在一个副本节点异常或者失败的情况下，写不成功。一般来说我们需要保证W>1。  \nR=1,W=3:这种分配对于读较多的场景较为友好，但是对于一个节点写失败的情况会导致等待此节点恢复写才能完成写的操作。  \nR=2,W=2:对比上面是一种较为优化的分配方案,虽然增加了读消耗的花费。  \n\n### 分段描述\n\n#### 写操作\n\n写操作分为一段或者两段  \n  1、发出一个读请求给所有的副本集合，等待一个读提议的回复，获取一个最大的版本号  \n  2、发出一个包含状态和最新版本的写请求给所有的副本集，等待一个写提议的返回，如果返回表示操作完成并返回状态码给client。  \n如果存在并发的写，需要使用方保持写的安全性。第一步的读请求可以避免，如果客户端知道正确的版本数据。\n\n#### 读操作\n\n读操作也可以分为一段或者两段请求  \n  1、发起一个读请求给所有的副本集合，等待一个读提议的返回，如果所有的版本返回一致的状态，那么返回结果给客户端。  \n  2、否则发起一个大版本数据的写请求给所有副本集合，等待写提议的返回，如果返回成功，则返回结果给客户端。  \n第二步称之为\"回写\"段，通常情况下，第二段是没必要的，因为在写请求的操作中所有可用的写返回是一致的数据，那么在读返回中，都是同样的返回数据。  \n### 特性\n\n协议需要提供原子性（线性性）  \n### 参考\n\n维基百科 [Quorum](https://en.wikipedia.org/wiki/Quorum \"Quorum\")\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["分布式","一致性"],"categories":["系统"]},{"title":"JAVA 内部锁与同步[Intrinsic Locks and Synchronization]","url":"/2014/03/12/lockAndSync/","content":"\nJAVA 内部锁与同步[Intrinsic Locks and Synchronization]\n\n同步是建立在被称之为内部锁或监控锁的内部实体（按照API标准指的这个实体称之为监控）。内在锁在同步的两个方面发挥作用：一个对象状态的专属使用权和建立可见性所需要的happens-before关系。\n<!-- more -->\n​      每个对象有一个与之相关联的内部锁。一般来说，一个线程需要持久的专有的访问一个对象的字段那么它必须先获取该对象的内部锁，当使用结束的时候释放这个锁。此时这个线程在获取内部锁后和释放这个内部锁之前都称之为拥有这个对象的内部锁。一旦这个线程拥有这个内部锁，其他的线程就不能获取同样的锁，获取的时候被阻塞住。\n\n​      当这个线程释放了这个内部锁，一个happens-before关系将建立在该动作和后续获取相同锁的操作之间。\n\n同步方法中的锁\n\n​    当一个线程调用一个同步方法事后，它会自动的获取这个方法对象的内部锁，直到方法返回才释放，即使未捕获的异常引起的返回也会触发这个锁的释放。\n\n如果一个静态的同步方法方法被调用，由于静态方法是关联到这个类而不是实例对象。这样的话，线程获取的是内部锁是与这个类相关的类对象。这个类的静态对象被锁住了。这个锁有区别于和此类的其他实例对象的锁\n\n同步块\n\n另外一种创建同步代码的的是使用同步块，和同步方法不相同，同步块需要具体的对象来提供内部锁。\n\n```java\npublic void addName(String name) {\n    synchronized(this) {\n        lastName = name;\n        nameCount++;\n    }\n    nameList.add(name);\n}\n```\n\n这个例子中，addName方法需要同步改变lastName和nameCount，但是同时也要避免去同步对其他对象方法的调用。如nameList.add方法在同步块外面，避免了同步这个方法。\n\n细粒度的同步块对于提供并发性能有着很好的改善，假设这样一个例子 MsLunch类有两个对象字段 c1和c2 ，它们不会交错使用。所有的这两个字段更新需要同步，但是没有必要c1的更新影响或者阻止c2的更新。减少并发通过创建不必要的阻塞而不是用同步方法或者this对象的同步块。我们可以创建两个对象提供锁。\n\n```java\npublic class MsLunch {\n    private long c1 = 0;\n    private long c2 = 0;\n    private Object lock1 = new Object(); // 注：推荐是用占用内存小的对象，如byte对象\n    private Object lock2 = new Object();\n\n    public void inc1() {\n        synchronized(lock1) {\n            c1++;\n        }\n    }\n\n    public void inc2() {\n        synchronized(lock2) {\n            c2++;\n        }\n    }\n}\n```\n\n这种风格的话，你必然能够保证相互影响的字段间交错访问的绝对安全。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java","译文"],"categories":["语言","JDK"]},{"title":"适配器模式概念简析","url":"/2013/10/06/adaptor/","content":"\n适配器模式的定义：将一个接口转化为另一个需要的接口。注接口为广义接口。\n\n例如： 我们有一个书籍的接口，其包含两个方法：获取作者，获取目录。\n<!-- more -->\n\n```java\npublic interface Book {\n    /**\n     * 书籍目录\n     */\n    public void getContents();\n\n\n    public void getAuthor();\n}\n```\n\n还有一个字典接口，也包含两个方法，获取作者，获取单词索引列表。\n\n```java\npublic interface Dictionary {\n    /**\n     * 字典没有目录 只有列表\n     */\n    public void getItems();\n\n\n    public void getAuthor();\n}\n```\n\n如何将字典接口转化为书籍接口，字典接口的实现类和书籍接口的实现类为同一种类型的类，那么就需要使用适配器模式。\n\n```java\npublic class DictAdapter implements Book {\n    Dictionary dictionary;\n\n    @Override\n    public void getContents() {\n        //字典 单词列表 转化为书籍目录\n        dictionary.getItems();\n    }\n\n    @Override\n    public void getAuthor() {\n        dictionary.getAuthor();\n    }\n\n}\n```\n\n分析：实现book接口的类，和字典对象作为组合方式联系起来。使用字典类的方法覆盖book接口的方法，从而达到目的。\n\n代码见：[DictAdapter.java](https://github.com/yangl326-Dylan/analysis_and_designer/blob/master/src/blog/DictAdapter.java)\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"String.valueOf()能否传入null","url":"/2013/09/11/string_null/","content":"\n最近发现一个有意思的问题，可以看看这两个的输出结果\n\n```\nString.valueOf(map.get(\"key\")) //①\n```\n\n```\nString.valueOf(null)          //②\n```\n<!-- more -->\n会发现map中①返回正常 ”null“字符串，而②抛出NLP异常\n\n跳转到String类的valueOf发现使用的是这个重载的方法：\n\n```java\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n```\n\n再看看char[] string的构造方法：\n\n```java\n    public String(char value[]) {\n        this.value = Arrays.copyOf(value, value.length);\n    }\n```\n\nnull无length属性，到这里就会异常。\n\n传入（Object）null时候（或者无key得时候map对象返回空对象），实现的是如下重载的方法：\n\n```java\n    public static String valueOf(Object obj) {\n        return (obj == null) ? \"null\" : obj.toString();\n    }\n```\n\n即正常返回 null字符串。\n\n实际上null是关键字，不属于Object对象，至于选择器为什么会优先选择重载函数就得分析null和Object obj=null 中 null和obj的区别了。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java"],"categories":["语言","JDK"]},{"title":"单例模式简析","url":"/2013/09/07/sington/","content":"\n### 含义\n\n什么叫单例模式或单件模式，由名字可知存在一个对象，我们可以重复使用这个对象。那么如何实现整个系统中存在一个对象，如何保证一个对象只被实例化一次。实际上约定一个全局变量可以，通过静态方法或者静态类的变量和一定限定修饰可以实现。实际中我们会遇到很多需要的场景，如果一个对象的初始化比较耗资源时间较长，并且可重复利用，那么就需要单例模式去实现。如：线程池、缓存、日志对象等，只需要一个对象就行了。\n\n创建对象 new一个实例，那么如何去保证这个对象实例只会存在一个。java对象缺省有无参构造器（构造方法），私有化这个构造方法，来看看几种实现方法。\n\n### 常见三种单例的实现方法\n\n首先想到的私有化构造方法，提供一个静态方法返回同一个对象：\n<!-- more -->\n\u001c\n\n```java\npublic class SingleTon {\n\n    private static SingleTon singleTon=null;\n\n    private SingleTon(){\n    }\n\n    public static SingleTon getInstance(){\n        if(singleTon == null){\n            singleTon = new SingleTon();    \n        }\n        return singleTon;\n    }\n\n}\n```\n\n分析：私有化其无参构造器后无法在这个类外去实例化这个对象，内部可以实例化这个对象，那么需要提供一个方法返回这个对象，使用静态方法，确保在类被加载的时候初始化到内存中，一个判断条件去保证这个对象是同一个对象。\n\n上面这段代码是延迟加载的，在调用getInstance方法的时候对象才被实例化，如果类被加载的时候初始化那么只需要将静态变量赋值：\n\n```java\npublic class SingleTon {\n\n    private static SingleTon singleTon=new SingleTon();\n\n    private SingleTon(){\n    }\n\n    public static SingleTon getInstance(){\n        return singleTon;\n    }\n\n}\n```\n\n如果在多线程情况下getInstance方法存在，并不能保证为同一个对象，简单的方法就是修改为同步方法，即：\n\n```\npublic static synchronized SingleTon getInstance(){}\n```\n\n简单方便，多线程问题解决，如果没有频繁使用的场景并且接受这种调用带来的资源消耗，那么同步的静态方法应该是一个比较好的方法，但是有一个问题，频繁的调用getInstance方法的时候，就不适合了。\n\n看看下面这种方法，双重检查加锁，保证只有一次同步方法，在创建的时候：\n\n```java\npublic class SingleTon {\n\n    private volatile static SingleTon singleTon;\n\n    private SingleTon(){\n    }\n\n    public static SingleTon getInstance(){\n        if(singleTon==null){\n            synchronized (SingleTon.class){\n                if(singleTon==null){\n                       singleTon = new SingleTon();\n                }\n            }\n        }\n        return singleTon;\n    }\n\n}\n```\n\n分析：\n\nvolatile 关键字修饰singleTon，表示各个线程自己的变量副本集不缓存，确保多线程初始化的时候，多线程正确处理这个变量。如果singleTon对象为空的时候，进入第一个if中的同步块，多线程受同步方法约束，再做一次null对象判断，为空才创建对象。之后的方法调用，进入不了同步块判断，那么就满足了只有一个同步判断的，减少了使用sychronized修饰方法每次调用的资源消耗，提高了执行效率，如果系统代码的性能要求较高，这种方式更为合适。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["设计模式"],"categories":["JDK"]},{"title":"final修饰符","url":"/2013/08/21/final-java/","content":"\n本文主要记载下java中final修饰符的应用场景，final 这个关键字定义修饰的实体不再改变，如何去理解这两个概念：“被修饰的实体”和”不再改变“。\n\nfinal可以修饰实体：\n<!-- more -->\n> 类（class）：表示此类不允许被继承；例如 java.lang.String 对象\n\n> 方法（method）：表示不能被重载\n\n> 变量（variables）：包括基本变量和引用的对象变量（注：final修饰的引用对象只要不被赋值，其属性的修改等是被允许的）。\n\n不再改变：\n\n> 不再改变不是不变的意思。如果变量final修饰为引用对象，不能为其赋值，而其自身可以变化，因为这个引用没有改变。\n\n定义在上面看怎么去理解了，还是用实例去验证下final的用法：\n\n一、final class（修饰类）：\n\n```\npublic final class FinalClass {...}// final 类\n\npublic class WrongClass extends FinalClass{...} //不被允许的继承\n\n```\n\n分析：不能编写一个final修饰类的子类，这个类所有的方法可以理解为隐含的final。\n\n二、final method（修饰方法）：\n\n```\n\tclass A{\n\t\tpublic void foo1(){}\n\t\tpublic final void foo2(){}\n\t}\n\tclass B extends A{ // 继承\n\n\t\tpublic void foo1() {} // okay\n\n\t\t@Override\n\t\tpublic void foo2() { // 重载不合法\n\t\t}\n\n\t\tpublic void foo2(int a){} //合法 重写foo2方法\n\t}\n```\n\n分析：方法 父类A中foo2 被关键字final修饰后，子类B去重载这个方法就是不被允许的，而其他的多态形式如重写是被允许的。通常父类的某方法不被让子类去重载掉，保持此方法的一致性。\n\n如下（为了方便，直接使用两个内部类作为例子）：\n\n```\npublic class FinalMethod {\n\n\tpublic static void main(String[] args) {\n\t\tFinalMethod aFinalMethod = new FinalMethod();\n\t\tB b = aFinalMethod.new B();\n\t\tb.foo2(); // 保持了foo2方法的一致性，A的子类使用的是相同的foo2，A不希望此方法被修改。\n\t}\n\n\tclass A{\n\t\tpublic void foo1(){}\n\t\tpublic final void foo2(){}\n\t}\n\n\tclass B extends A{ // 继承\n\t\tpublic void foo1() {} // okay\n\t\t//public void foo2(int a){} //合法 重写foo2方法\n\t}\n\n}\n```\n\n三、final variable（变量）：\n\n就像本文开头叙述的一样修饰基本型变量和修饰引用型变量，看下面两种变量：\n\n```\nfinal int a = 10；\na = 1;//error 不允许\nfinal List<String> list = new ArrayList<String>();\nlist.add(\"str\");//okay\n```\n\n```\nlist = new ArrayList<String>();// error 不被允许\n```\n\n分析： 基本型 a final 修饰赋值后不能被改变。 final修饰list 引用，只要不被赋值，此对象可以变化，而这个引用不允许被修改为另一个引用。\n\n修饰变量需要提到如下两种：\n\n3.1、blank final： is a final variable whose declaration lacks an initializer 一个声明缺少初始化的final变量。如下是合法的：\n\n```\nfor(final String str: strList){\n//do in loop;\n}\n```\n\n分析：可以这样去理解，变量作用域问题，每次循环是一个新的执行块，那么这样的final声明是合法的。\n\n3.2、匿名内部类使用外部变量final修饰\n\n为什么需要final修饰？\n\n当一个匿名内部类的定义是自身内的一种方法，所有的变量声明为final的范围，方法是从内部类访问。一旦它已经被分配，最后的变量的值不能改变的。这将允许Java编译器来“捕获”的变量值在运行时间和存储一份内部类中作为一个字段。一旦外部方法已经终止和它的堆栈帧已被删除，原来的变量收回了，但自己的内存在类的内部类的私有副本仍然存在。\n\n```\n\tpublic static void main(String[] args) {\n\t\t// String aString  = \"haha~\";// 无法被调用 不合法\n\t\tfinal String aString  = \"haha~\"; // okay\n\t\tThread a = new Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(aString);// 调用外部变量\n\t\t\t}\n\t\t});\n\t\ta.start();\n\t}\n```\n\n分析：结合上述原理，aString在内部类实际为outer的副本，那么就必须保证aString不能被改变，内部类调用外部变量的原理为自身存储外部变量的副本，那么保证数据一致性，在设计方面就限定了被调用的外部变量需要final修饰。\n\n\\-----------------------------------\n\ncode文件：[FinalInner.java](https://github.com/yangl326-Dylan/analysis_and_designer/blob/master/src/blog/FinalInner.java) [FinalVariables.java](https://github.com/yangl326-Dylan/analysis_and_designer/blob/master/src/blog/FinalVariables.java) [FinalMethod.java](https://github.com/yangl326-Dylan/analysis_and_designer/blob/master/src/blog/FinalMethod.java)\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java","final"],"categories":["语言","JDK"]},{"title":"JVM工作原理理解和分析--类加载","url":"/2013/08/20/classloader/","content":"\nJVM (Java Virtual Machine) 即java虚拟机。一个java文件对应一个类，JVM会把需要的类装载到内存，那么class loader的作用就出来了。\n\n先抛出个常见的问题 ClassNotFoundException 常见于缺少的加载类文件或相关库文件或者重复加载等。\n<!-- more -->\nJVM的类加载机制为委托加载（双亲委派模型）我们看一下classloader的流程图（引自参考）\n\n![img](http://img.blog.csdn.net/20130820132524921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2wzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n一、classloader之间的父子关系(非继承关系)和范围。\n(1)BootStrap 是最顶层的类加载器，由C++编写,也称之为启动类加载器,主要用来读取Java的核心类库%java_home%/jre/lib/rt.jar 或指定能被JVM识别的文件\n(2)Extension ClassLoader,  java 编写，用来读取Java的扩展类库，读取%java_home%/jre/lib/ext/*.jar 或者指定路径的文件\n(3)App ClassLoader， java编写，是用来读取CLASSPATH指定的所有jar包或目录的类文件：引入的文件\n(4)Custom ClassLoader是用户自定义编写classloader子类的用来加载指定类文件。\n\n二、双亲委派模型的过程：\n\n需要加载A类，先自底向上查看此类是否被加载，如果未被加载，那么依次从启动加载器开始尝试加载此类，未找到抛出异常。（详细可参见classloader源代码），java中常规的加载流程如上。\n\n我们来看一个简单的例子：\n\n```java\npublic class JVMClassLoader {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tJVMClassLoader hello = new JVMClassLoader();\n\t\tClass helloClass = hello.getClass();\n\t\tSystem.out.println(\"ClassLoader str: \" + \"\".getClass().getClassLoader());\n\t\tSystem.out.println(\"ClassLoader a  : \" + helloClass.getClassLoader());\n\t\tSystem.out.println(\"ClassLoader-ap : \" + helloClass.getClassLoader().getParent());\n\t\tSystem.out.println(\"ClassLoader-app: \" + helloClass.getClassLoader().getParent().getParent());\n\t}\n\t/*\n\t * result:\n\t * ClassLoader str: null\n\t * ClassLoader a  : sun.misc.Launcher$AppClassLoader@62f72617\n\t * ClassLoader-ap : sun.misc.Launcher$ExtClassLoader@4fe5e2c3\n\t * ClassLoader-app: null\n\t */\n\n}\n```\n\n\n\n首先string对象类的加载器为null（即启动加载bootstrap加载器,无法去使用）str类应该属于rt.jar库中对象\n\n自定义类JVMClassLoader 类它是由AppClassLoader加载，而AppClassLoader是由ExtClassLoader加载，ExtclassLoader由bootstrap加载器加载。\n\n可以做个这样的测试把编译好的文件打包成jar放置到lib/ext/目录下 那么输出其加载器应该是ExtClassLoader\n\n推荐：\n\n`java -verbose:class 完整类名`    类加载器跟踪,尽可能多的输出加载信息\n\n### 引申问题\n\ntomcat的web app项目的类加载顺序，常用的库放置路径，关键路径：tomcat/lib  和WEB-INF/lib 。想一想 一个tomcat实例下面可以多个app，不同app使用不同版本的jar库，那么怎样的加载优先级可以保证。\n\n### 参考\n\nhttp://www.cnblogs.com/ChrisWang/archive/2009/11/17/Inside-JVM-4-ClassLoader-Knowledge-Sharing.html\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**\n","tags":["java"],"categories":["语言","JDK"]},{"title":"ArrayList删除元素问题及问题扩展","url":"/2013/06/11/arraylist-remove/","content":"\n初学者容易犯错的细小问题，collection集合类（ArrayList list Hashmap）中移除元素问题。\n\n其它集合会出现类似问题，java遍历中移除元素某些情况不会提示任何错误信息，因为是合法，但会引起数据问题，不易被发现。其他语言也类似如python按照dict的items去遍历出现del(key)会引发个错误。\n\n所以遍历的时候一定得考虑是否对被遍历对象做过了修改，你去遍历的是什么对象，遍历的循环中操作的又是什么对象。\n\n下面正对ArrayList移除某一对象问题做个分析：\n\n问题：ArrayList<>String对象包含如下字符串  \"a\", \"b\", \"c\", \"c\", \"d\"。 现在我们需要移除所有的c字符串，都知道list的remove方法只能移除首次出现的这个对象。\n\n于是很容易就想到遍历这个collection遇到c的移除掉，看如下代码：\n\n缺省listA，B，C，D 四个相同的arraylist对象，移除所有c字符串。\n\n```java\nString[] tmp = {\"a\",\"b\",\"c\",\"c\",\"d\"};\n\t\tList<String> listA = new ArrayList<String>();\n\t\tList<String> listB = new ArrayList<String>();\n\t\tList<String> listC = new ArrayList<String>();\n\t\tList<String> listD = new ArrayList<String>();\n\t\tfor(String str:tmp){\n\t\t\tlistA.add(str);\n\t\t\tlistB.add(str);\n\t\t\tlistC.add(str);\n\t\t\tlistD.add(str);\n\t\t}//listA B C D 装有相同tmp数组中的对象\n```\n\n容易犯错的代码：\n\n```java\n//listA.remove(\"c\");//仅仅移除第一次出现的c，那么很容易想到去遍历遇到c都remove（索引）\n\t\tfor (int i = 0; i < listA.size(); i++) {\n\t\t\tif (listA.get(i).equals(\"c\")) {\n\t\t\t\tlistA.remove(i);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(listA);// 结果：[a, b, c, d] 为什么第二个c没有被全部移除掉? 不会出现错误或者异常，见分析\n```\n\n分析：顺序遍历，循环的第3次 即索引2的位置的时候碰到第一个c的，移除掉，此时listA的大小改变了，而下次循环的时候2索引后面的元素实际索引都变化了。而循环的遍历索引变为3了从d开始，相邻的第二个c元素被跳过了，就是错误结果了。\n\n解决方法有如下几种，还是希望明白本文开头的黑体字。\n\n方法一：根据上述的分析那么最简单的方法便是倒序遍历\n\n```java\n//倒序移除\n\t\tfor (int i = listB.size() -1; i>=0; i--) {\n\t\t\tif (listB.get(i).equals(\"c\")) {\n\t\t\t\tlistB.remove(i);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(listB); //结果：[a, b, d] 符合期望\n```\n\n分析：倒序遍历后 遍历过的元素因当前元素被移除而引起的索引变化已经无关紧要了，因为已经遍历过了。保证未遍历的索引不变化，那么所有的元素都会被处理到的。\n\n方法二：使用removeAll，只不过它的参数是个集合，方法的定义是移除所有包含的所有元素。（注意‘所有包含’和‘所有’）\n\n```java\n//使用 removeAll包装起来需要移除的元素\n\t\tList<String> tmpDel = new ArrayList<String>();\n\t\ttmpDel.add(\"c\");\n\t\tlistC.removeAll(tmpDel);//移除tmpDel所包含的其 所有元素\n\t\tSystem.out.println(listC); //结果：[a, b, d] 符合期望\n```\n\n分析： 看removeAll的文档：它指的是移除所有包含的所有元素，两个所有。\n\n方法三：\n\n使用迭代器Iterator，使用的时候注意迭代器的原理。有些用法是错误的，比如说在迭代中修改被迭代的对象\n\n```java\n//使用迭代器 注意正确用法见注释部分\n\t\tIterator<String> iterator = listD.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif(iterator.next().equals(\"c\")){\n\t\t\t\titerator.remove();\n\t\t\t\t//listD.remove(\"c\"); // error Iterator是工作在一个独立的线程，不允许迭代的对象被改变，否则会并发异常\n\t\t\t};\n\t\t\t\n\t\t}\n\t\tSystem.out.println(listD); //结果：[a, b, d] 符合期望\n```\n\n分析：listD是被迭代的对象，Iterator被创建的时候，建立了一个内存索引表（单链表），这 个索引表指向原来的对象，当被迭代的对象改变的时候，这个索引表的内容没有同步改变，所以当索引指针往下移动的时候，便找不到要迭代的对象，使用注释的代码会产生错误。\n\n---\n\n**版权声明：本文为博主原创文章，未经允许不得转载。**","tags":["java","collection"],"categories":["JDK"]},{"title":"About ME","url":"/2013/02/13/about/","content":"\n## be honest with yourself and then the world.\n\nemail:zhoudunyang[at]gmail.com  \nwechat:  \n![weixin](about/weixin_qr.png)\n","tags":["about","contact"],"categories":["关于"]}]